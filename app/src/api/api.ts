/* tslint:disable */
/* eslint-disable */
/**
 * BotBeri API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface BotCreate
 */
export interface BotCreate {
    /**
     * 
     * @type {string}
     * @memberof BotCreate
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof BotCreate
     */
    'description': string;
    /**
     * 
     * @type {object}
     * @memberof BotCreate
     */
    'content'?: object;
    /**
     * 
     * @type {string}
     * @memberof BotCreate
     */
    'activation_code': string;
    /**
     * 
     * @type {number}
     * @memberof BotCreate
     */
    'rate': number;
}
/**
 * 
 * @export
 * @interface BotOut
 */
export interface BotOut {
    /**
     * 
     * @type {number}
     * @memberof BotOut
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof BotOut
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof BotOut
     */
    'description': string;
    /**
     * 
     * @type {object}
     * @memberof BotOut
     */
    'content': object;
    /**
     * 
     * @type {string}
     * @memberof BotOut
     */
    'activation_code': string;
    /**
     * 
     * @type {number}
     * @memberof BotOut
     */
    'rate': number;
}
/**
 * 
 * @export
 * @interface BotUpdate
 */
export interface BotUpdate {
    /**
     * 
     * @type {string}
     * @memberof BotUpdate
     */
    'title'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BotUpdate
     */
    'description'?: string | null;
    /**
     * 
     * @type {object}
     * @memberof BotUpdate
     */
    'content'?: object | null;
    /**
     * 
     * @type {string}
     * @memberof BotUpdate
     */
    'activation_code'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof BotUpdate
     */
    'rate'?: number | null;
}
/**
 * 
 * @export
 * @interface ChangePasswordIn
 */
export interface ChangePasswordIn {
    /**
     * 
     * @type {string}
     * @memberof ChangePasswordIn
     */
    'current_password': string;
    /**
     * 
     * @type {string}
     * @memberof ChangePasswordIn
     */
    'new_password': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ErrorCode = {
    InternalError: 'internal_error',
    BadRequest: 'bad_request',
    ValidationError: 'validation_error',
    Unauthorized: 'unauthorized',
    Forbidden: 'forbidden',
    NotFound: 'not_found',
    Conflict: 'conflict',
    RateLimited: 'rate_limited',
    ServiceUnavailable: 'service_unavailable',
    Timeout: 'timeout',
    EmailAlreadyRegistered: 'email_already_registered',
    PhoneAlreadyRegistered: 'phone_already_registered',
    InvalidCredentials: 'invalid_credentials',
    LoginBlocked: 'login_blocked',
    EmailNotVerified: 'email_not_verified',
    VerificationCodeInvalid: 'verification_code_invalid',
    VerificationCodeExpired: 'verification_code_expired',
    VerificationResendTooSoon: 'verification_resend_too_soon',
    TokenMissing: 'token_missing',
    TokenInvalid: 'token_invalid',
    TokenExpired: 'token_expired',
    SessionInvalid: 'session_invalid',
    SessionExpired: 'session_expired',
    AdminTokenInvalid: 'admin_token_invalid',
    PasswordTooWeak: 'password_too_weak',
    PasswordSameAsOld: 'password_same_as_old',
    PasswordResetInvalid: 'password_reset_invalid',
    PasswordResetExpired: 'password_reset_expired',
    PasswordResetUsed: 'password_reset_used',
    UserNotFound: 'user_not_found',
    UserUpdateFailed: 'user_update_failed',
    UserBalanceTooLow: 'user_balance_too_low',
    BotNotFound: 'bot_not_found',
    BotAlreadyExists: 'bot_already_exists',
    BotActivationCodeInvalid: 'bot_activation_code_invalid',
    BotRateInvalid: 'bot_rate_invalid',
    BotDeleteForbidden: 'bot_delete_forbidden',
    InstanceNotFound: 'instance_not_found',
    InstanceCreationFailed: 'instance_creation_failed',
    InstanceIdAlreadyExists: 'instance_id_already_exists',
    InstanceConfigInvalid: 'instance_config_invalid',
    InstanceAlreadyActive: 'instance_already_active',
    InstanceAlreadyPaused: 'instance_already_paused',
    InstanceNotEnoughBalance: 'instance_not_enough_balance',
    EmailSendFailed: 'email_send_failed',
    MailTransportUnavailable: 'mail_transport_unavailable',
    DatabaseError: 'database_error',
    UniqueConstraintViolation: 'unique_constraint_violation',
    RedisError: 'redis_error',
    ExternalApiError: 'external_api_error',
    ExternalApiTimeout: 'external_api_timeout',
    ExternalApiUnauthorized: 'external_api_unauthorized',
    ConfigError: 'config_error'
} as const;

export type ErrorCode = typeof ErrorCode[keyof typeof ErrorCode];


/**
 * 
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * 
     * @type {ErrorCode}
     * @memberof ErrorResponse
     */
    'error_code': ErrorCode;
    /**
     * 
     * @type {string}
     * @memberof ErrorResponse
     */
    'user_message'?: string | null;
    /**
     * 
     * @type {object}
     * @memberof ErrorResponse
     */
    'details'?: object | null;
}


/**
 * 
 * @export
 * @interface ForgotPasswordIn
 */
export interface ForgotPasswordIn {
    /**
     * 
     * @type {string}
     * @memberof ForgotPasswordIn
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
    /**
     * 
     * @type {Array<ValidationError>}
     * @memberof HTTPValidationError
     */
    'detail'?: Array<ValidationError>;
}
/**
 * 
 * @export
 * @interface InstanceCreate
 */
export interface InstanceCreate {
    /**
     * 
     * @type {number}
     * @memberof InstanceCreate
     */
    'bot_id': number;
    /**
     * 
     * @type {string}
     * @memberof InstanceCreate
     */
    'title': string;
    /**
     * 
     * @type {object}
     * @memberof InstanceCreate
     */
    'config'?: object;
}
/**
 * 
 * @export
 * @interface InstanceDetailOut
 */
export interface InstanceDetailOut {
    /**
     * 
     * @type {number}
     * @memberof InstanceDetailOut
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof InstanceDetailOut
     */
    'user_id': number;
    /**
     * 
     * @type {number}
     * @memberof InstanceDetailOut
     */
    'bot_id': number;
    /**
     * 
     * @type {string}
     * @memberof InstanceDetailOut
     */
    'instance_id': string;
    /**
     * 
     * @type {string}
     * @memberof InstanceDetailOut
     */
    'title': string;
    /**
     * 
     * @type {object}
     * @memberof InstanceDetailOut
     */
    'config': object;
    /**
     * 
     * @type {InstanceStatus}
     * @memberof InstanceDetailOut
     */
    'status': InstanceStatus;
    /**
     * 
     * @type {KnowledgeBaseOut}
     * @memberof InstanceDetailOut
     */
    'kb'?: KnowledgeBaseOut | null;
}


/**
 * 
 * @export
 * @interface InstanceOut
 */
export interface InstanceOut {
    /**
     * 
     * @type {number}
     * @memberof InstanceOut
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof InstanceOut
     */
    'user_id': number;
    /**
     * 
     * @type {number}
     * @memberof InstanceOut
     */
    'bot_id': number;
    /**
     * 
     * @type {string}
     * @memberof InstanceOut
     */
    'instance_id': string;
    /**
     * 
     * @type {string}
     * @memberof InstanceOut
     */
    'title': string;
    /**
     * 
     * @type {object}
     * @memberof InstanceOut
     */
    'config': object;
    /**
     * 
     * @type {InstanceStatus}
     * @memberof InstanceOut
     */
    'status': InstanceStatus;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const InstanceStatus = {
    Active: 'active',
    Paused: 'paused',
    NotEnoughBalance: 'not_enough_balance',
    Provisioning: 'provisioning',
    Inactive: 'inactive',
    Updating: 'updating',
    Deleting: 'deleting',
    Error: 'error',
    Unknown: 'unknown'
} as const;

export type InstanceStatus = typeof InstanceStatus[keyof typeof InstanceStatus];


/**
 * 
 * @export
 * @interface InstanceStatusUpdate
 */
export interface InstanceStatusUpdate {
    /**
     * 
     * @type {InstanceStatus}
     * @memberof InstanceStatusUpdate
     */
    'status': InstanceStatus;
}


/**
 * 
 * @export
 * @interface InstanceUpdate
 */
export interface InstanceUpdate {
    /**
     * 
     * @type {string}
     * @memberof InstanceUpdate
     */
    'title'?: string | null;
    /**
     * 
     * @type {object}
     * @memberof InstanceUpdate
     */
    'config'?: object | null;
    /**
     * 
     * @type {InstanceStatus}
     * @memberof InstanceUpdate
     */
    'status'?: InstanceStatus | null;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const KBDataType = {
    Document: 'document',
    Video: 'video'
} as const;

export type KBDataType = typeof KBDataType[keyof typeof KBDataType];


/**
 * 
 * @export
 * @interface KBEntryCreate
 */
export interface KBEntryCreate {
    /**
     * 
     * @type {string}
     * @memberof KBEntryCreate
     */
    'content': string;
    /**
     * 
     * @type {KBDataType}
     * @memberof KBEntryCreate
     */
    'data_type'?: KBDataType | null;
    /**
     * 
     * @type {KBLangHint}
     * @memberof KBEntryCreate
     */
    'lang_hint'?: KBLangHint | null;
}


/**
 * 
 * @export
 * @interface KBEntryOut
 */
export interface KBEntryOut {
    /**
     * 
     * @type {number}
     * @memberof KBEntryOut
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof KBEntryOut
     */
    'content': string;
    /**
     * 
     * @type {KBDataType}
     * @memberof KBEntryOut
     */
    'data_type': KBDataType;
    /**
     * 
     * @type {KBLangHint}
     * @memberof KBEntryOut
     */
    'lang_hint': KBLangHint;
    /**
     * 
     * @type {KBEntryStatus}
     * @memberof KBEntryOut
     */
    'status': KBEntryStatus;
    /**
     * 
     * @type {string}
     * @memberof KBEntryOut
     */
    'external_entry_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof KBEntryOut
     */
    'execution_id'?: string | null;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const KBEntryStatus = {
    InProgress: 'in_progress',
    Done: 'done',
    Timeout: 'timeout',
    Failed: 'failed'
} as const;

export type KBEntryStatus = typeof KBEntryStatus[keyof typeof KBEntryStatus];


/**
 * 
 * @export
 * @enum {string}
 */

export const KBLangHint = {
    Ru: 'ru',
    En: 'en',
    Uk: 'uk',
    Tr: 'tr',
    De: 'de',
    Fr: 'fr',
    Es: 'es',
    It: 'it',
    Pt: 'pt',
    Pl: 'pl',
    Kk: 'kk',
    Uz: 'uz',
    Az: 'az',
    Ka: 'ka',
    Ro: 'ro',
    Nl: 'nl',
    Sv: 'sv',
    No: 'no',
    Da: 'da',
    Fi: 'fi',
    Cs: 'cs',
    Sk: 'sk',
    Bg: 'bg',
    Sr: 'sr',
    Hr: 'hr',
    Sl: 'sl',
    Et: 'et',
    Lt: 'lt',
    Lv: 'lv',
    El: 'el',
    He: 'he',
    Ar: 'ar',
    Fa: 'fa',
    Hi: 'hi',
    Ur: 'ur',
    Bn: 'bn',
    Ta: 'ta',
    Te: 'te',
    Ml: 'ml',
    Id: 'id',
    Ms: 'ms',
    Th: 'th',
    Vi: 'vi',
    Zh: 'zh',
    Ja: 'ja',
    Ko: 'ko'
} as const;

export type KBLangHint = typeof KBLangHint[keyof typeof KBLangHint];


/**
 * 
 * @export
 * @interface KnowledgeBaseOut
 */
export interface KnowledgeBaseOut {
    /**
     * 
     * @type {number}
     * @memberof KnowledgeBaseOut
     */
    'id': number;
    /**
     * 
     * @type {Array<KBEntryOut>}
     * @memberof KnowledgeBaseOut
     */
    'entries'?: Array<KBEntryOut>;
}
/**
 * 
 * @export
 * @interface LocationInner
 */
export interface LocationInner {
}
/**
 * 
 * @export
 * @interface LoginIn
 */
export interface LoginIn {
    /**
     * 
     * @type {string}
     * @memberof LoginIn
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof LoginIn
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface Message
 */
export interface Message {
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface RegisterIn
 */
export interface RegisterIn {
    /**
     * 
     * @type {string}
     * @memberof RegisterIn
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof RegisterIn
     */
    'surname': string;
    /**
     * 
     * @type {string}
     * @memberof RegisterIn
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof RegisterIn
     */
    'phone': string;
    /**
     * 
     * @type {string}
     * @memberof RegisterIn
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof RegisterIn
     */
    'telegram'?: string | null;
}
/**
 * 
 * @export
 * @interface ResetPasswordIn
 */
export interface ResetPasswordIn {
    /**
     * 
     * @type {string}
     * @memberof ResetPasswordIn
     */
    'token': string;
    /**
     * 
     * @type {string}
     * @memberof ResetPasswordIn
     */
    'new_password': string;
}
/**
 * 
 * @export
 * @interface StatusEventOut
 */
export interface StatusEventOut {
    /**
     * 
     * @type {number}
     * @memberof StatusEventOut
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof StatusEventOut
     */
    'changed_at': string;
    /**
     * 
     * @type {string}
     * @memberof StatusEventOut
     */
    'from_status': string | null;
    /**
     * 
     * @type {string}
     * @memberof StatusEventOut
     */
    'to_status': string;
}
/**
 * 
 * @export
 * @interface StatusSegmentOut
 */
export interface StatusSegmentOut {
    /**
     * 
     * @type {string}
     * @memberof StatusSegmentOut
     */
    'start': string;
    /**
     * 
     * @type {string}
     * @memberof StatusSegmentOut
     */
    'end': string;
    /**
     * 
     * @type {InstanceStatus}
     * @memberof StatusSegmentOut
     */
    'status': InstanceStatus;
    /**
     * 
     * @type {number}
     * @memberof StatusSegmentOut
     */
    'seconds': number;
}


/**
 * 
 * @export
 * @interface StatusStatsOut
 */
export interface StatusStatsOut {
    /**
     * 
     * @type {string}
     * @memberof StatusStatsOut
     */
    'window_start': string;
    /**
     * 
     * @type {string}
     * @memberof StatusStatsOut
     */
    'window_end': string;
    /**
     * 
     * @type {number}
     * @memberof StatusStatsOut
     */
    'total_seconds': number;
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof StatusStatsOut
     */
    'seconds_by_status': { [key: string]: number; };
    /**
     * 
     * @type {number}
     * @memberof StatusStatsOut
     */
    'uptime_seconds': number;
    /**
     * 
     * @type {number}
     * @memberof StatusStatsOut
     */
    'uptime_percent': number;
    /**
     * 
     * @type {Array<StatusSegmentOut>}
     * @memberof StatusStatsOut
     */
    'segments'?: Array<StatusSegmentOut> | null;
}
/**
 * 
 * @export
 * @interface TokenPair
 */
export interface TokenPair {
    /**
     * 
     * @type {string}
     * @memberof TokenPair
     */
    'session_token': string;
    /**
     * 
     * @type {string}
     * @memberof TokenPair
     */
    'refresh_token': string;
}
/**
 * 
 * @export
 * @interface UserOut
 */
export interface UserOut {
    /**
     * 
     * @type {number}
     * @memberof UserOut
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof UserOut
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof UserOut
     */
    'surname': string;
    /**
     * 
     * @type {string}
     * @memberof UserOut
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof UserOut
     */
    'phone': string;
    /**
     * 
     * @type {string}
     * @memberof UserOut
     */
    'telegram'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof UserOut
     */
    'balance': number;
}
/**
 * 
 * @export
 * @interface UserUpdate
 */
export interface UserUpdate {
    /**
     * 
     * @type {string}
     * @memberof UserUpdate
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserUpdate
     */
    'surname'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserUpdate
     */
    'phone'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserUpdate
     */
    'telegram'?: string | null;
}
/**
 * 
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * 
     * @type {Array<LocationInner>}
     * @memberof ValidationError
     */
    'loc': Array<LocationInner>;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface VerifyEmailIn
 */
export interface VerifyEmailIn {
    /**
     * 
     * @type {string}
     * @memberof VerifyEmailIn
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof VerifyEmailIn
     */
    'code': string;
}

/**
 * AdminApi - axios parameter creator
 * @export
 */
export const AdminApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get User
         * @param {number} uid 
         * @param {string | null} [xAdminKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAdminUsersUidGet: async (uid: number, xAdminKey?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('getUserAdminUsersUidGet', 'uid', uid)
            const localVarPath = `/admin/users/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (xAdminKey != null) {
                localVarHeaderParameter['X-Admin-Key'] = String(xAdminKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Users
         * @param {string | null} [xAdminKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsersAdminUsersGet: async (xAdminKey?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (xAdminKey != null) {
                localVarHeaderParameter['X-Admin-Key'] = String(xAdminKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch User
         * @param {number} uid 
         * @param {object} body 
         * @param {string | null} [xAdminKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchUserAdminUsersUidPatch: async (uid: number, body: object, xAdminKey?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('patchUserAdminUsersUidPatch', 'uid', uid)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('patchUserAdminUsersUidPatch', 'body', body)
            const localVarPath = `/admin/users/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xAdminKey != null) {
                localVarHeaderParameter['X-Admin-Key'] = String(xAdminKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminApi - functional programming interface
 * @export
 */
export const AdminApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdminApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get User
         * @param {number} uid 
         * @param {string | null} [xAdminKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserAdminUsersUidGet(uid: number, xAdminKey?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserAdminUsersUidGet(uid, xAdminKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.getUserAdminUsersUidGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List Users
         * @param {string | null} [xAdminKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUsersAdminUsersGet(xAdminKey?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserOut>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUsersAdminUsersGet(xAdminKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.listUsersAdminUsersGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Patch User
         * @param {number} uid 
         * @param {object} body 
         * @param {string | null} [xAdminKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchUserAdminUsersUidPatch(uid: number, body: object, xAdminKey?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchUserAdminUsersUidPatch(uid, body, xAdminKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.patchUserAdminUsersUidPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AdminApi - factory interface
 * @export
 */
export const AdminApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdminApiFp(configuration)
    return {
        /**
         * 
         * @summary Get User
         * @param {number} uid 
         * @param {string | null} [xAdminKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAdminUsersUidGet(uid: number, xAdminKey?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<UserOut> {
            return localVarFp.getUserAdminUsersUidGet(uid, xAdminKey, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Users
         * @param {string | null} [xAdminKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsersAdminUsersGet(xAdminKey?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<Array<UserOut>> {
            return localVarFp.listUsersAdminUsersGet(xAdminKey, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Patch User
         * @param {number} uid 
         * @param {object} body 
         * @param {string | null} [xAdminKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchUserAdminUsersUidPatch(uid: number, body: object, xAdminKey?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<UserOut> {
            return localVarFp.patchUserAdminUsersUidPatch(uid, body, xAdminKey, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminApi - object-oriented interface
 * @export
 * @class AdminApi
 * @extends {BaseAPI}
 */
export class AdminApi extends BaseAPI {
    /**
     * 
     * @summary Get User
     * @param {number} uid 
     * @param {string | null} [xAdminKey] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public getUserAdminUsersUidGet(uid: number, xAdminKey?: string | null, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).getUserAdminUsersUidGet(uid, xAdminKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Users
     * @param {string | null} [xAdminKey] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public listUsersAdminUsersGet(xAdminKey?: string | null, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).listUsersAdminUsersGet(xAdminKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Patch User
     * @param {number} uid 
     * @param {object} body 
     * @param {string | null} [xAdminKey] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public patchUserAdminUsersUidPatch(uid: number, body: object, xAdminKey?: string | null, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).patchUserAdminUsersUidPatch(uid, body, xAdminKey, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Change Password
         * @param {ChangePasswordIn} changePasswordIn 
         * @param {any} [xSessionToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePasswordAuthChangePasswordPost: async (changePasswordIn: ChangePasswordIn, xSessionToken?: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'changePasswordIn' is not null or undefined
            assertParamExists('changePasswordAuthChangePasswordPost', 'changePasswordIn', changePasswordIn)
            const localVarPath = `/auth/change-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xSessionToken != null) {
                localVarHeaderParameter['X-Session-Token'] = typeof xSessionToken === 'string'
                    ? xSessionToken
                    : JSON.stringify(xSessionToken);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(changePasswordIn, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Forgot Password
         * @param {ForgotPasswordIn} forgotPasswordIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forgotPasswordAuthForgotPasswordPost: async (forgotPasswordIn: ForgotPasswordIn, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'forgotPasswordIn' is not null or undefined
            assertParamExists('forgotPasswordAuthForgotPasswordPost', 'forgotPasswordIn', forgotPasswordIn)
            const localVarPath = `/auth/forgot-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(forgotPasswordIn, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Login
         * @param {LoginIn} loginIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginAuthLoginPost: async (loginIn: LoginIn, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginIn' is not null or undefined
            assertParamExists('loginAuthLoginPost', 'loginIn', loginIn)
            const localVarPath = `/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginIn, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Logout
         * @param {string | null} [xSessionToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutAuthLogoutPost: async (xSessionToken?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (xSessionToken != null) {
                localVarHeaderParameter['X-Session-Token'] = String(xSessionToken);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Refresh
         * @param {string | null} [xSessionToken] 
         * @param {string | null} [xRefreshToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshAuthRefreshPost: async (xSessionToken?: string | null, xRefreshToken?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (xSessionToken != null) {
                localVarHeaderParameter['X-Session-Token'] = String(xSessionToken);
            }
            if (xRefreshToken != null) {
                localVarHeaderParameter['X-Refresh-Token'] = String(xRefreshToken);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Register
         * @param {RegisterIn} registerIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerAuthRegisterPost: async (registerIn: RegisterIn, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'registerIn' is not null or undefined
            assertParamExists('registerAuthRegisterPost', 'registerIn', registerIn)
            const localVarPath = `/auth/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registerIn, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reset Password
         * @param {ResetPasswordIn} resetPasswordIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPasswordAuthResetPasswordPost: async (resetPasswordIn: ResetPasswordIn, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resetPasswordIn' is not null or undefined
            assertParamExists('resetPasswordAuthResetPasswordPost', 'resetPasswordIn', resetPasswordIn)
            const localVarPath = `/auth/reset-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resetPasswordIn, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Verify Email
         * @param {VerifyEmailIn} verifyEmailIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyEmailAuthVerifyEmailPost: async (verifyEmailIn: VerifyEmailIn, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'verifyEmailIn' is not null or undefined
            assertParamExists('verifyEmailAuthVerifyEmailPost', 'verifyEmailIn', verifyEmailIn)
            const localVarPath = `/auth/verify-email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(verifyEmailIn, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Change Password
         * @param {ChangePasswordIn} changePasswordIn 
         * @param {any} [xSessionToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changePasswordAuthChangePasswordPost(changePasswordIn: ChangePasswordIn, xSessionToken?: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenPair>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changePasswordAuthChangePasswordPost(changePasswordIn, xSessionToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.changePasswordAuthChangePasswordPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Forgot Password
         * @param {ForgotPasswordIn} forgotPasswordIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async forgotPasswordAuthForgotPasswordPost(forgotPasswordIn: ForgotPasswordIn, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.forgotPasswordAuthForgotPasswordPost(forgotPasswordIn, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.forgotPasswordAuthForgotPasswordPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Login
         * @param {LoginIn} loginIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loginAuthLoginPost(loginIn: LoginIn, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenPair>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loginAuthLoginPost(loginIn, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.loginAuthLoginPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Logout
         * @param {string | null} [xSessionToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logoutAuthLogoutPost(xSessionToken?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logoutAuthLogoutPost(xSessionToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.logoutAuthLogoutPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Refresh
         * @param {string | null} [xSessionToken] 
         * @param {string | null} [xRefreshToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshAuthRefreshPost(xSessionToken?: string | null, xRefreshToken?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenPair>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshAuthRefreshPost(xSessionToken, xRefreshToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.refreshAuthRefreshPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Register
         * @param {RegisterIn} registerIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerAuthRegisterPost(registerIn: RegisterIn, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerAuthRegisterPost(registerIn, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.registerAuthRegisterPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Reset Password
         * @param {ResetPasswordIn} resetPasswordIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetPasswordAuthResetPasswordPost(resetPasswordIn: ResetPasswordIn, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetPasswordAuthResetPasswordPost(resetPasswordIn, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.resetPasswordAuthResetPasswordPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Verify Email
         * @param {VerifyEmailIn} verifyEmailIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifyEmailAuthVerifyEmailPost(verifyEmailIn: VerifyEmailIn, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenPair>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verifyEmailAuthVerifyEmailPost(verifyEmailIn, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.verifyEmailAuthVerifyEmailPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * 
         * @summary Change Password
         * @param {ChangePasswordIn} changePasswordIn 
         * @param {any} [xSessionToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePasswordAuthChangePasswordPost(changePasswordIn: ChangePasswordIn, xSessionToken?: any, options?: RawAxiosRequestConfig): AxiosPromise<TokenPair> {
            return localVarFp.changePasswordAuthChangePasswordPost(changePasswordIn, xSessionToken, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Forgot Password
         * @param {ForgotPasswordIn} forgotPasswordIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forgotPasswordAuthForgotPasswordPost(forgotPasswordIn: ForgotPasswordIn, options?: RawAxiosRequestConfig): AxiosPromise<Message> {
            return localVarFp.forgotPasswordAuthForgotPasswordPost(forgotPasswordIn, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Login
         * @param {LoginIn} loginIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginAuthLoginPost(loginIn: LoginIn, options?: RawAxiosRequestConfig): AxiosPromise<TokenPair> {
            return localVarFp.loginAuthLoginPost(loginIn, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Logout
         * @param {string | null} [xSessionToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutAuthLogoutPost(xSessionToken?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<Message> {
            return localVarFp.logoutAuthLogoutPost(xSessionToken, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Refresh
         * @param {string | null} [xSessionToken] 
         * @param {string | null} [xRefreshToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshAuthRefreshPost(xSessionToken?: string | null, xRefreshToken?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<TokenPair> {
            return localVarFp.refreshAuthRefreshPost(xSessionToken, xRefreshToken, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Register
         * @param {RegisterIn} registerIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerAuthRegisterPost(registerIn: RegisterIn, options?: RawAxiosRequestConfig): AxiosPromise<Message> {
            return localVarFp.registerAuthRegisterPost(registerIn, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reset Password
         * @param {ResetPasswordIn} resetPasswordIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPasswordAuthResetPasswordPost(resetPasswordIn: ResetPasswordIn, options?: RawAxiosRequestConfig): AxiosPromise<Message> {
            return localVarFp.resetPasswordAuthResetPasswordPost(resetPasswordIn, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Verify Email
         * @param {VerifyEmailIn} verifyEmailIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyEmailAuthVerifyEmailPost(verifyEmailIn: VerifyEmailIn, options?: RawAxiosRequestConfig): AxiosPromise<TokenPair> {
            return localVarFp.verifyEmailAuthVerifyEmailPost(verifyEmailIn, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * 
     * @summary Change Password
     * @param {ChangePasswordIn} changePasswordIn 
     * @param {any} [xSessionToken] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public changePasswordAuthChangePasswordPost(changePasswordIn: ChangePasswordIn, xSessionToken?: any, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).changePasswordAuthChangePasswordPost(changePasswordIn, xSessionToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Forgot Password
     * @param {ForgotPasswordIn} forgotPasswordIn 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public forgotPasswordAuthForgotPasswordPost(forgotPasswordIn: ForgotPasswordIn, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).forgotPasswordAuthForgotPasswordPost(forgotPasswordIn, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Login
     * @param {LoginIn} loginIn 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public loginAuthLoginPost(loginIn: LoginIn, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).loginAuthLoginPost(loginIn, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Logout
     * @param {string | null} [xSessionToken] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public logoutAuthLogoutPost(xSessionToken?: string | null, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).logoutAuthLogoutPost(xSessionToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Refresh
     * @param {string | null} [xSessionToken] 
     * @param {string | null} [xRefreshToken] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public refreshAuthRefreshPost(xSessionToken?: string | null, xRefreshToken?: string | null, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).refreshAuthRefreshPost(xSessionToken, xRefreshToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Register
     * @param {RegisterIn} registerIn 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public registerAuthRegisterPost(registerIn: RegisterIn, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).registerAuthRegisterPost(registerIn, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reset Password
     * @param {ResetPasswordIn} resetPasswordIn 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public resetPasswordAuthResetPasswordPost(resetPasswordIn: ResetPasswordIn, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).resetPasswordAuthResetPasswordPost(resetPasswordIn, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Verify Email
     * @param {VerifyEmailIn} verifyEmailIn 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public verifyEmailAuthVerifyEmailPost(verifyEmailIn: VerifyEmailIn, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).verifyEmailAuthVerifyEmailPost(verifyEmailIn, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BotsApi - axios parameter creator
 * @export
 */
export const BotsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Bot
         * @param {BotCreate} botCreate 
         * @param {string | null} [xAdminKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBotBotsPost: async (botCreate: BotCreate, xAdminKey?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'botCreate' is not null or undefined
            assertParamExists('createBotBotsPost', 'botCreate', botCreate)
            const localVarPath = `/bots`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xAdminKey != null) {
                localVarHeaderParameter['X-Admin-Key'] = String(xAdminKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(botCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Bot
         * @param {number} botId 
         * @param {string | null} [xAdminKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBotBotsBotIdDelete: async (botId: number, xAdminKey?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'botId' is not null or undefined
            assertParamExists('deleteBotBotsBotIdDelete', 'botId', botId)
            const localVarPath = `/bots/{bot_id}`
                .replace(`{${"bot_id"}}`, encodeURIComponent(String(botId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (xAdminKey != null) {
                localVarHeaderParameter['X-Admin-Key'] = String(xAdminKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Bots
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBotsBotsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/bots`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Bot
         * @param {number} botId 
         * @param {BotUpdate} botUpdate 
         * @param {string | null} [xAdminKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBotBotsBotIdPut: async (botId: number, botUpdate: BotUpdate, xAdminKey?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'botId' is not null or undefined
            assertParamExists('updateBotBotsBotIdPut', 'botId', botId)
            // verify required parameter 'botUpdate' is not null or undefined
            assertParamExists('updateBotBotsBotIdPut', 'botUpdate', botUpdate)
            const localVarPath = `/bots/{bot_id}`
                .replace(`{${"bot_id"}}`, encodeURIComponent(String(botId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xAdminKey != null) {
                localVarHeaderParameter['X-Admin-Key'] = String(xAdminKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(botUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BotsApi - functional programming interface
 * @export
 */
export const BotsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BotsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create Bot
         * @param {BotCreate} botCreate 
         * @param {string | null} [xAdminKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBotBotsPost(botCreate: BotCreate, xAdminKey?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BotOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBotBotsPost(botCreate, xAdminKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BotsApi.createBotBotsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Bot
         * @param {number} botId 
         * @param {string | null} [xAdminKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBotBotsBotIdDelete(botId: number, xAdminKey?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteBotBotsBotIdDelete(botId, xAdminKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BotsApi.deleteBotBotsBotIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List Bots
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listBotsBotsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BotOut>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listBotsBotsGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BotsApi.listBotsBotsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Bot
         * @param {number} botId 
         * @param {BotUpdate} botUpdate 
         * @param {string | null} [xAdminKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateBotBotsBotIdPut(botId: number, botUpdate: BotUpdate, xAdminKey?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BotOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateBotBotsBotIdPut(botId, botUpdate, xAdminKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BotsApi.updateBotBotsBotIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BotsApi - factory interface
 * @export
 */
export const BotsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BotsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create Bot
         * @param {BotCreate} botCreate 
         * @param {string | null} [xAdminKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBotBotsPost(botCreate: BotCreate, xAdminKey?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<BotOut> {
            return localVarFp.createBotBotsPost(botCreate, xAdminKey, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Bot
         * @param {number} botId 
         * @param {string | null} [xAdminKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBotBotsBotIdDelete(botId: number, xAdminKey?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.deleteBotBotsBotIdDelete(botId, xAdminKey, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Bots
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBotsBotsGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<BotOut>> {
            return localVarFp.listBotsBotsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Bot
         * @param {number} botId 
         * @param {BotUpdate} botUpdate 
         * @param {string | null} [xAdminKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBotBotsBotIdPut(botId: number, botUpdate: BotUpdate, xAdminKey?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<BotOut> {
            return localVarFp.updateBotBotsBotIdPut(botId, botUpdate, xAdminKey, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BotsApi - object-oriented interface
 * @export
 * @class BotsApi
 * @extends {BaseAPI}
 */
export class BotsApi extends BaseAPI {
    /**
     * 
     * @summary Create Bot
     * @param {BotCreate} botCreate 
     * @param {string | null} [xAdminKey] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotsApi
     */
    public createBotBotsPost(botCreate: BotCreate, xAdminKey?: string | null, options?: RawAxiosRequestConfig) {
        return BotsApiFp(this.configuration).createBotBotsPost(botCreate, xAdminKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Bot
     * @param {number} botId 
     * @param {string | null} [xAdminKey] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotsApi
     */
    public deleteBotBotsBotIdDelete(botId: number, xAdminKey?: string | null, options?: RawAxiosRequestConfig) {
        return BotsApiFp(this.configuration).deleteBotBotsBotIdDelete(botId, xAdminKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Bots
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotsApi
     */
    public listBotsBotsGet(options?: RawAxiosRequestConfig) {
        return BotsApiFp(this.configuration).listBotsBotsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Bot
     * @param {number} botId 
     * @param {BotUpdate} botUpdate 
     * @param {string | null} [xAdminKey] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotsApi
     */
    public updateBotBotsBotIdPut(botId: number, botUpdate: BotUpdate, xAdminKey?: string | null, options?: RawAxiosRequestConfig) {
        return BotsApiFp(this.configuration).updateBotBotsBotIdPut(botId, botUpdate, xAdminKey, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * InstancesApi - axios parameter creator
 * @export
 */
export const InstancesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Instance
         * @param {InstanceCreate} instanceCreate 
         * @param {string | null} [xSessionToken] 
         * @param {string | null} [xRefreshToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInstanceInstancesPost: async (instanceCreate: InstanceCreate, xSessionToken?: string | null, xRefreshToken?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'instanceCreate' is not null or undefined
            assertParamExists('createInstanceInstancesPost', 'instanceCreate', instanceCreate)
            const localVarPath = `/instances`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xSessionToken != null) {
                localVarHeaderParameter['X-Session-Token'] = String(xSessionToken);
            }
            if (xRefreshToken != null) {
                localVarHeaderParameter['X-Refresh-Token'] = String(xRefreshToken);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(instanceCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Instance
         * @param {number} iid 
         * @param {string | null} [xSessionToken] 
         * @param {string | null} [xRefreshToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInstanceInstancesIidDelete: async (iid: number, xSessionToken?: string | null, xRefreshToken?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'iid' is not null or undefined
            assertParamExists('deleteInstanceInstancesIidDelete', 'iid', iid)
            const localVarPath = `/instances/{iid}`
                .replace(`{${"iid"}}`, encodeURIComponent(String(iid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (xSessionToken != null) {
                localVarHeaderParameter['X-Session-Token'] = String(xSessionToken);
            }
            if (xRefreshToken != null) {
                localVarHeaderParameter['X-Refresh-Token'] = String(xRefreshToken);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Instance
         * @param {number} iid 
         * @param {string | null} [xSessionToken] 
         * @param {string | null} [xRefreshToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstanceInstancesIidGet: async (iid: number, xSessionToken?: string | null, xRefreshToken?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'iid' is not null or undefined
            assertParamExists('getInstanceInstancesIidGet', 'iid', iid)
            const localVarPath = `/instances/{iid}`
                .replace(`{${"iid"}}`, encodeURIComponent(String(iid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (xSessionToken != null) {
                localVarHeaderParameter['X-Session-Token'] = String(xSessionToken);
            }
            if (xRefreshToken != null) {
                localVarHeaderParameter['X-Refresh-Token'] = String(xRefreshToken);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Instance Stats
         * @param {number} iid 
         * @param {string} from 
         * @param {string} to 
         * @param {boolean} [includeSegments] 
         * @param {string | null} [xSessionToken] 
         * @param {string | null} [xRefreshToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstanceStatsInstancesIidStatsGet: async (iid: number, from: string, to: string, includeSegments?: boolean, xSessionToken?: string | null, xRefreshToken?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'iid' is not null or undefined
            assertParamExists('getInstanceStatsInstancesIidStatsGet', 'iid', iid)
            // verify required parameter 'from' is not null or undefined
            assertParamExists('getInstanceStatsInstancesIidStatsGet', 'from', from)
            // verify required parameter 'to' is not null or undefined
            assertParamExists('getInstanceStatsInstancesIidStatsGet', 'to', to)
            const localVarPath = `/instances/{iid}/stats`
                .replace(`{${"iid"}}`, encodeURIComponent(String(iid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (from !== undefined) {
                localVarQueryParameter['from'] = (from as any instanceof Date) ?
                    (from as any).toISOString() :
                    from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = (to as any instanceof Date) ?
                    (to as any).toISOString() :
                    to;
            }

            if (includeSegments !== undefined) {
                localVarQueryParameter['include_segments'] = includeSegments;
            }


    
            if (xSessionToken != null) {
                localVarHeaderParameter['X-Session-Token'] = String(xSessionToken);
            }
            if (xRefreshToken != null) {
                localVarHeaderParameter['X-Refresh-Token'] = String(xRefreshToken);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Status Events
         * @param {number} iid 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string | null} [from] 
         * @param {string | null} [to] 
         * @param {string | null} [xSessionToken] 
         * @param {string | null} [xRefreshToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatusEventsInstancesIidStatusEventsGet: async (iid: number, limit?: number, offset?: number, from?: string | null, to?: string | null, xSessionToken?: string | null, xRefreshToken?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'iid' is not null or undefined
            assertParamExists('getStatusEventsInstancesIidStatusEventsGet', 'iid', iid)
            const localVarPath = `/instances/{iid}/status-events`
                .replace(`{${"iid"}}`, encodeURIComponent(String(iid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (from !== undefined) {
                localVarQueryParameter['from'] = (from as any instanceof Date) ?
                    (from as any).toISOString() :
                    from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = (to as any instanceof Date) ?
                    (to as any).toISOString() :
                    to;
            }


    
            if (xSessionToken != null) {
                localVarHeaderParameter['X-Session-Token'] = String(xSessionToken);
            }
            if (xRefreshToken != null) {
                localVarHeaderParameter['X-Refresh-Token'] = String(xRefreshToken);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Kb Add Entry
         * @param {number} iid 
         * @param {KBEntryCreate} kBEntryCreate 
         * @param {string | null} [xSessionToken] 
         * @param {string | null} [xRefreshToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        kbAddEntryInstancesIidKbEntriesPost: async (iid: number, kBEntryCreate: KBEntryCreate, xSessionToken?: string | null, xRefreshToken?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'iid' is not null or undefined
            assertParamExists('kbAddEntryInstancesIidKbEntriesPost', 'iid', iid)
            // verify required parameter 'kBEntryCreate' is not null or undefined
            assertParamExists('kbAddEntryInstancesIidKbEntriesPost', 'kBEntryCreate', kBEntryCreate)
            const localVarPath = `/instances/{iid}/kb/entries`
                .replace(`{${"iid"}}`, encodeURIComponent(String(iid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xSessionToken != null) {
                localVarHeaderParameter['X-Session-Token'] = String(xSessionToken);
            }
            if (xRefreshToken != null) {
                localVarHeaderParameter['X-Refresh-Token'] = String(xRefreshToken);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(kBEntryCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Kb Delete Entry Route
         * @param {number} iid 
         * @param {number} entryId 
         * @param {string | null} [xSessionToken] 
         * @param {string | null} [xRefreshToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        kbDeleteEntryRouteInstancesIidKbEntriesEntryIdDelete: async (iid: number, entryId: number, xSessionToken?: string | null, xRefreshToken?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'iid' is not null or undefined
            assertParamExists('kbDeleteEntryRouteInstancesIidKbEntriesEntryIdDelete', 'iid', iid)
            // verify required parameter 'entryId' is not null or undefined
            assertParamExists('kbDeleteEntryRouteInstancesIidKbEntriesEntryIdDelete', 'entryId', entryId)
            const localVarPath = `/instances/{iid}/kb/entries/{entry_id}`
                .replace(`{${"iid"}}`, encodeURIComponent(String(iid)))
                .replace(`{${"entry_id"}}`, encodeURIComponent(String(entryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (xSessionToken != null) {
                localVarHeaderParameter['X-Session-Token'] = String(xSessionToken);
            }
            if (xRefreshToken != null) {
                localVarHeaderParameter['X-Refresh-Token'] = String(xRefreshToken);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Instances
         * @param {string | null} [xSessionToken] 
         * @param {string | null} [xRefreshToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInstancesInstancesGet: async (xSessionToken?: string | null, xRefreshToken?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/instances`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (xSessionToken != null) {
                localVarHeaderParameter['X-Session-Token'] = String(xSessionToken);
            }
            if (xRefreshToken != null) {
                localVarHeaderParameter['X-Refresh-Token'] = String(xRefreshToken);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set Instance Status
         * @param {number} iid 
         * @param {InstanceStatusUpdate} instanceStatusUpdate 
         * @param {string | null} [xAdminToken] 
         * @param {string | null} [xSessionToken] 
         * @param {string | null} [xRefreshToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setInstanceStatusInstancesIidStatusPatch: async (iid: number, instanceStatusUpdate: InstanceStatusUpdate, xAdminToken?: string | null, xSessionToken?: string | null, xRefreshToken?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'iid' is not null or undefined
            assertParamExists('setInstanceStatusInstancesIidStatusPatch', 'iid', iid)
            // verify required parameter 'instanceStatusUpdate' is not null or undefined
            assertParamExists('setInstanceStatusInstancesIidStatusPatch', 'instanceStatusUpdate', instanceStatusUpdate)
            const localVarPath = `/instances/{iid}/status`
                .replace(`{${"iid"}}`, encodeURIComponent(String(iid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xAdminToken != null) {
                localVarHeaderParameter['X-Admin-Token'] = String(xAdminToken);
            }
            if (xSessionToken != null) {
                localVarHeaderParameter['X-Session-Token'] = String(xSessionToken);
            }
            if (xRefreshToken != null) {
                localVarHeaderParameter['X-Refresh-Token'] = String(xRefreshToken);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(instanceStatusUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Instance
         * @param {number} iid 
         * @param {InstanceUpdate} instanceUpdate 
         * @param {string | null} [xSessionToken] 
         * @param {string | null} [xRefreshToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInstanceInstancesIidPut: async (iid: number, instanceUpdate: InstanceUpdate, xSessionToken?: string | null, xRefreshToken?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'iid' is not null or undefined
            assertParamExists('updateInstanceInstancesIidPut', 'iid', iid)
            // verify required parameter 'instanceUpdate' is not null or undefined
            assertParamExists('updateInstanceInstancesIidPut', 'instanceUpdate', instanceUpdate)
            const localVarPath = `/instances/{iid}`
                .replace(`{${"iid"}}`, encodeURIComponent(String(iid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xSessionToken != null) {
                localVarHeaderParameter['X-Session-Token'] = String(xSessionToken);
            }
            if (xRefreshToken != null) {
                localVarHeaderParameter['X-Refresh-Token'] = String(xRefreshToken);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(instanceUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InstancesApi - functional programming interface
 * @export
 */
export const InstancesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InstancesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create Instance
         * @param {InstanceCreate} instanceCreate 
         * @param {string | null} [xSessionToken] 
         * @param {string | null} [xRefreshToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createInstanceInstancesPost(instanceCreate: InstanceCreate, xSessionToken?: string | null, xRefreshToken?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InstanceOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createInstanceInstancesPost(instanceCreate, xSessionToken, xRefreshToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InstancesApi.createInstanceInstancesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Instance
         * @param {number} iid 
         * @param {string | null} [xSessionToken] 
         * @param {string | null} [xRefreshToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteInstanceInstancesIidDelete(iid: number, xSessionToken?: string | null, xRefreshToken?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteInstanceInstancesIidDelete(iid, xSessionToken, xRefreshToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InstancesApi.deleteInstanceInstancesIidDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Instance
         * @param {number} iid 
         * @param {string | null} [xSessionToken] 
         * @param {string | null} [xRefreshToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInstanceInstancesIidGet(iid: number, xSessionToken?: string | null, xRefreshToken?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InstanceDetailOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInstanceInstancesIidGet(iid, xSessionToken, xRefreshToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InstancesApi.getInstanceInstancesIidGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Instance Stats
         * @param {number} iid 
         * @param {string} from 
         * @param {string} to 
         * @param {boolean} [includeSegments] 
         * @param {string | null} [xSessionToken] 
         * @param {string | null} [xRefreshToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInstanceStatsInstancesIidStatsGet(iid: number, from: string, to: string, includeSegments?: boolean, xSessionToken?: string | null, xRefreshToken?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatusStatsOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInstanceStatsInstancesIidStatsGet(iid, from, to, includeSegments, xSessionToken, xRefreshToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InstancesApi.getInstanceStatsInstancesIidStatsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Status Events
         * @param {number} iid 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string | null} [from] 
         * @param {string | null} [to] 
         * @param {string | null} [xSessionToken] 
         * @param {string | null} [xRefreshToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatusEventsInstancesIidStatusEventsGet(iid: number, limit?: number, offset?: number, from?: string | null, to?: string | null, xSessionToken?: string | null, xRefreshToken?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<StatusEventOut>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatusEventsInstancesIidStatusEventsGet(iid, limit, offset, from, to, xSessionToken, xRefreshToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InstancesApi.getStatusEventsInstancesIidStatusEventsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Kb Add Entry
         * @param {number} iid 
         * @param {KBEntryCreate} kBEntryCreate 
         * @param {string | null} [xSessionToken] 
         * @param {string | null} [xRefreshToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async kbAddEntryInstancesIidKbEntriesPost(iid: number, kBEntryCreate: KBEntryCreate, xSessionToken?: string | null, xRefreshToken?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KBEntryOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.kbAddEntryInstancesIidKbEntriesPost(iid, kBEntryCreate, xSessionToken, xRefreshToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InstancesApi.kbAddEntryInstancesIidKbEntriesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Kb Delete Entry Route
         * @param {number} iid 
         * @param {number} entryId 
         * @param {string | null} [xSessionToken] 
         * @param {string | null} [xRefreshToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async kbDeleteEntryRouteInstancesIidKbEntriesEntryIdDelete(iid: number, entryId: number, xSessionToken?: string | null, xRefreshToken?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.kbDeleteEntryRouteInstancesIidKbEntriesEntryIdDelete(iid, entryId, xSessionToken, xRefreshToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InstancesApi.kbDeleteEntryRouteInstancesIidKbEntriesEntryIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List Instances
         * @param {string | null} [xSessionToken] 
         * @param {string | null} [xRefreshToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listInstancesInstancesGet(xSessionToken?: string | null, xRefreshToken?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InstanceOut>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listInstancesInstancesGet(xSessionToken, xRefreshToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InstancesApi.listInstancesInstancesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Set Instance Status
         * @param {number} iid 
         * @param {InstanceStatusUpdate} instanceStatusUpdate 
         * @param {string | null} [xAdminToken] 
         * @param {string | null} [xSessionToken] 
         * @param {string | null} [xRefreshToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setInstanceStatusInstancesIidStatusPatch(iid: number, instanceStatusUpdate: InstanceStatusUpdate, xAdminToken?: string | null, xSessionToken?: string | null, xRefreshToken?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InstanceOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setInstanceStatusInstancesIidStatusPatch(iid, instanceStatusUpdate, xAdminToken, xSessionToken, xRefreshToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InstancesApi.setInstanceStatusInstancesIidStatusPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Instance
         * @param {number} iid 
         * @param {InstanceUpdate} instanceUpdate 
         * @param {string | null} [xSessionToken] 
         * @param {string | null} [xRefreshToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateInstanceInstancesIidPut(iid: number, instanceUpdate: InstanceUpdate, xSessionToken?: string | null, xRefreshToken?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InstanceOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateInstanceInstancesIidPut(iid, instanceUpdate, xSessionToken, xRefreshToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InstancesApi.updateInstanceInstancesIidPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * InstancesApi - factory interface
 * @export
 */
export const InstancesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InstancesApiFp(configuration)
    return {
        /**
         * 
         * @summary Create Instance
         * @param {InstanceCreate} instanceCreate 
         * @param {string | null} [xSessionToken] 
         * @param {string | null} [xRefreshToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInstanceInstancesPost(instanceCreate: InstanceCreate, xSessionToken?: string | null, xRefreshToken?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<InstanceOut> {
            return localVarFp.createInstanceInstancesPost(instanceCreate, xSessionToken, xRefreshToken, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Instance
         * @param {number} iid 
         * @param {string | null} [xSessionToken] 
         * @param {string | null} [xRefreshToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInstanceInstancesIidDelete(iid: number, xSessionToken?: string | null, xRefreshToken?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.deleteInstanceInstancesIidDelete(iid, xSessionToken, xRefreshToken, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Instance
         * @param {number} iid 
         * @param {string | null} [xSessionToken] 
         * @param {string | null} [xRefreshToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstanceInstancesIidGet(iid: number, xSessionToken?: string | null, xRefreshToken?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<InstanceDetailOut> {
            return localVarFp.getInstanceInstancesIidGet(iid, xSessionToken, xRefreshToken, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Instance Stats
         * @param {number} iid 
         * @param {string} from 
         * @param {string} to 
         * @param {boolean} [includeSegments] 
         * @param {string | null} [xSessionToken] 
         * @param {string | null} [xRefreshToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstanceStatsInstancesIidStatsGet(iid: number, from: string, to: string, includeSegments?: boolean, xSessionToken?: string | null, xRefreshToken?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<StatusStatsOut> {
            return localVarFp.getInstanceStatsInstancesIidStatsGet(iid, from, to, includeSegments, xSessionToken, xRefreshToken, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Status Events
         * @param {number} iid 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string | null} [from] 
         * @param {string | null} [to] 
         * @param {string | null} [xSessionToken] 
         * @param {string | null} [xRefreshToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatusEventsInstancesIidStatusEventsGet(iid: number, limit?: number, offset?: number, from?: string | null, to?: string | null, xSessionToken?: string | null, xRefreshToken?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<Array<StatusEventOut>> {
            return localVarFp.getStatusEventsInstancesIidStatusEventsGet(iid, limit, offset, from, to, xSessionToken, xRefreshToken, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Kb Add Entry
         * @param {number} iid 
         * @param {KBEntryCreate} kBEntryCreate 
         * @param {string | null} [xSessionToken] 
         * @param {string | null} [xRefreshToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        kbAddEntryInstancesIidKbEntriesPost(iid: number, kBEntryCreate: KBEntryCreate, xSessionToken?: string | null, xRefreshToken?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<KBEntryOut> {
            return localVarFp.kbAddEntryInstancesIidKbEntriesPost(iid, kBEntryCreate, xSessionToken, xRefreshToken, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Kb Delete Entry Route
         * @param {number} iid 
         * @param {number} entryId 
         * @param {string | null} [xSessionToken] 
         * @param {string | null} [xRefreshToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        kbDeleteEntryRouteInstancesIidKbEntriesEntryIdDelete(iid: number, entryId: number, xSessionToken?: string | null, xRefreshToken?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.kbDeleteEntryRouteInstancesIidKbEntriesEntryIdDelete(iid, entryId, xSessionToken, xRefreshToken, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Instances
         * @param {string | null} [xSessionToken] 
         * @param {string | null} [xRefreshToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInstancesInstancesGet(xSessionToken?: string | null, xRefreshToken?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<Array<InstanceOut>> {
            return localVarFp.listInstancesInstancesGet(xSessionToken, xRefreshToken, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set Instance Status
         * @param {number} iid 
         * @param {InstanceStatusUpdate} instanceStatusUpdate 
         * @param {string | null} [xAdminToken] 
         * @param {string | null} [xSessionToken] 
         * @param {string | null} [xRefreshToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setInstanceStatusInstancesIidStatusPatch(iid: number, instanceStatusUpdate: InstanceStatusUpdate, xAdminToken?: string | null, xSessionToken?: string | null, xRefreshToken?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<InstanceOut> {
            return localVarFp.setInstanceStatusInstancesIidStatusPatch(iid, instanceStatusUpdate, xAdminToken, xSessionToken, xRefreshToken, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Instance
         * @param {number} iid 
         * @param {InstanceUpdate} instanceUpdate 
         * @param {string | null} [xSessionToken] 
         * @param {string | null} [xRefreshToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInstanceInstancesIidPut(iid: number, instanceUpdate: InstanceUpdate, xSessionToken?: string | null, xRefreshToken?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<InstanceOut> {
            return localVarFp.updateInstanceInstancesIidPut(iid, instanceUpdate, xSessionToken, xRefreshToken, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InstancesApi - object-oriented interface
 * @export
 * @class InstancesApi
 * @extends {BaseAPI}
 */
export class InstancesApi extends BaseAPI {
    /**
     * 
     * @summary Create Instance
     * @param {InstanceCreate} instanceCreate 
     * @param {string | null} [xSessionToken] 
     * @param {string | null} [xRefreshToken] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstancesApi
     */
    public createInstanceInstancesPost(instanceCreate: InstanceCreate, xSessionToken?: string | null, xRefreshToken?: string | null, options?: RawAxiosRequestConfig) {
        return InstancesApiFp(this.configuration).createInstanceInstancesPost(instanceCreate, xSessionToken, xRefreshToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Instance
     * @param {number} iid 
     * @param {string | null} [xSessionToken] 
     * @param {string | null} [xRefreshToken] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstancesApi
     */
    public deleteInstanceInstancesIidDelete(iid: number, xSessionToken?: string | null, xRefreshToken?: string | null, options?: RawAxiosRequestConfig) {
        return InstancesApiFp(this.configuration).deleteInstanceInstancesIidDelete(iid, xSessionToken, xRefreshToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Instance
     * @param {number} iid 
     * @param {string | null} [xSessionToken] 
     * @param {string | null} [xRefreshToken] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstancesApi
     */
    public getInstanceInstancesIidGet(iid: number, xSessionToken?: string | null, xRefreshToken?: string | null, options?: RawAxiosRequestConfig) {
        return InstancesApiFp(this.configuration).getInstanceInstancesIidGet(iid, xSessionToken, xRefreshToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Instance Stats
     * @param {number} iid 
     * @param {string} from 
     * @param {string} to 
     * @param {boolean} [includeSegments] 
     * @param {string | null} [xSessionToken] 
     * @param {string | null} [xRefreshToken] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstancesApi
     */
    public getInstanceStatsInstancesIidStatsGet(iid: number, from: string, to: string, includeSegments?: boolean, xSessionToken?: string | null, xRefreshToken?: string | null, options?: RawAxiosRequestConfig) {
        return InstancesApiFp(this.configuration).getInstanceStatsInstancesIidStatsGet(iid, from, to, includeSegments, xSessionToken, xRefreshToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Status Events
     * @param {number} iid 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {string | null} [from] 
     * @param {string | null} [to] 
     * @param {string | null} [xSessionToken] 
     * @param {string | null} [xRefreshToken] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstancesApi
     */
    public getStatusEventsInstancesIidStatusEventsGet(iid: number, limit?: number, offset?: number, from?: string | null, to?: string | null, xSessionToken?: string | null, xRefreshToken?: string | null, options?: RawAxiosRequestConfig) {
        return InstancesApiFp(this.configuration).getStatusEventsInstancesIidStatusEventsGet(iid, limit, offset, from, to, xSessionToken, xRefreshToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Kb Add Entry
     * @param {number} iid 
     * @param {KBEntryCreate} kBEntryCreate 
     * @param {string | null} [xSessionToken] 
     * @param {string | null} [xRefreshToken] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstancesApi
     */
    public kbAddEntryInstancesIidKbEntriesPost(iid: number, kBEntryCreate: KBEntryCreate, xSessionToken?: string | null, xRefreshToken?: string | null, options?: RawAxiosRequestConfig) {
        return InstancesApiFp(this.configuration).kbAddEntryInstancesIidKbEntriesPost(iid, kBEntryCreate, xSessionToken, xRefreshToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Kb Delete Entry Route
     * @param {number} iid 
     * @param {number} entryId 
     * @param {string | null} [xSessionToken] 
     * @param {string | null} [xRefreshToken] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstancesApi
     */
    public kbDeleteEntryRouteInstancesIidKbEntriesEntryIdDelete(iid: number, entryId: number, xSessionToken?: string | null, xRefreshToken?: string | null, options?: RawAxiosRequestConfig) {
        return InstancesApiFp(this.configuration).kbDeleteEntryRouteInstancesIidKbEntriesEntryIdDelete(iid, entryId, xSessionToken, xRefreshToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Instances
     * @param {string | null} [xSessionToken] 
     * @param {string | null} [xRefreshToken] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstancesApi
     */
    public listInstancesInstancesGet(xSessionToken?: string | null, xRefreshToken?: string | null, options?: RawAxiosRequestConfig) {
        return InstancesApiFp(this.configuration).listInstancesInstancesGet(xSessionToken, xRefreshToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set Instance Status
     * @param {number} iid 
     * @param {InstanceStatusUpdate} instanceStatusUpdate 
     * @param {string | null} [xAdminToken] 
     * @param {string | null} [xSessionToken] 
     * @param {string | null} [xRefreshToken] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstancesApi
     */
    public setInstanceStatusInstancesIidStatusPatch(iid: number, instanceStatusUpdate: InstanceStatusUpdate, xAdminToken?: string | null, xSessionToken?: string | null, xRefreshToken?: string | null, options?: RawAxiosRequestConfig) {
        return InstancesApiFp(this.configuration).setInstanceStatusInstancesIidStatusPatch(iid, instanceStatusUpdate, xAdminToken, xSessionToken, xRefreshToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Instance
     * @param {number} iid 
     * @param {InstanceUpdate} instanceUpdate 
     * @param {string | null} [xSessionToken] 
     * @param {string | null} [xRefreshToken] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstancesApi
     */
    public updateInstanceInstancesIidPut(iid: number, instanceUpdate: InstanceUpdate, xSessionToken?: string | null, xRefreshToken?: string | null, options?: RawAxiosRequestConfig) {
        return InstancesApiFp(this.configuration).updateInstanceInstancesIidPut(iid, instanceUpdate, xSessionToken, xRefreshToken, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Me
         * @param {string | null} [xSessionToken] 
         * @param {string | null} [xRefreshToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMeUsersMeGet: async (xSessionToken?: string | null, xRefreshToken?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (xSessionToken != null) {
                localVarHeaderParameter['X-Session-Token'] = String(xSessionToken);
            }
            if (xRefreshToken != null) {
                localVarHeaderParameter['X-Refresh-Token'] = String(xRefreshToken);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Me
         * @param {UserUpdate} userUpdate 
         * @param {string | null} [xSessionToken] 
         * @param {string | null} [xRefreshToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMeUsersMePatch: async (userUpdate: UserUpdate, xSessionToken?: string | null, xRefreshToken?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userUpdate' is not null or undefined
            assertParamExists('updateMeUsersMePatch', 'userUpdate', userUpdate)
            const localVarPath = `/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xSessionToken != null) {
                localVarHeaderParameter['X-Session-Token'] = String(xSessionToken);
            }
            if (xRefreshToken != null) {
                localVarHeaderParameter['X-Refresh-Token'] = String(xRefreshToken);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get Me
         * @param {string | null} [xSessionToken] 
         * @param {string | null} [xRefreshToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMeUsersMeGet(xSessionToken?: string | null, xRefreshToken?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMeUsersMeGet(xSessionToken, xRefreshToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getMeUsersMeGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Me
         * @param {UserUpdate} userUpdate 
         * @param {string | null} [xSessionToken] 
         * @param {string | null} [xRefreshToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMeUsersMePatch(userUpdate: UserUpdate, xSessionToken?: string | null, xRefreshToken?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMeUsersMePatch(userUpdate, xSessionToken, xRefreshToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.updateMeUsersMePatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * 
         * @summary Get Me
         * @param {string | null} [xSessionToken] 
         * @param {string | null} [xRefreshToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMeUsersMeGet(xSessionToken?: string | null, xRefreshToken?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<UserOut> {
            return localVarFp.getMeUsersMeGet(xSessionToken, xRefreshToken, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Me
         * @param {UserUpdate} userUpdate 
         * @param {string | null} [xSessionToken] 
         * @param {string | null} [xRefreshToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMeUsersMePatch(userUpdate: UserUpdate, xSessionToken?: string | null, xRefreshToken?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<UserOut> {
            return localVarFp.updateMeUsersMePatch(userUpdate, xSessionToken, xRefreshToken, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * 
     * @summary Get Me
     * @param {string | null} [xSessionToken] 
     * @param {string | null} [xRefreshToken] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getMeUsersMeGet(xSessionToken?: string | null, xRefreshToken?: string | null, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getMeUsersMeGet(xSessionToken, xRefreshToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Me
     * @param {UserUpdate} userUpdate 
     * @param {string | null} [xSessionToken] 
     * @param {string | null} [xRefreshToken] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateMeUsersMePatch(userUpdate: UserUpdate, xSessionToken?: string | null, xRefreshToken?: string | null, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateMeUsersMePatch(userUpdate, xSessionToken, xRefreshToken, options).then((request) => request(this.axios, this.basePath));
    }
}



