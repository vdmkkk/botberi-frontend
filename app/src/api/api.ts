/* tslint:disable */
/* eslint-disable */
/**
 * BotBeri API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface BotCreate
 */
export interface BotCreate {
    /**
     * 
     * @type {string}
     * @memberof BotCreate
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof BotCreate
     */
    'description': string;
    /**
     * 
     * @type {object}
     * @memberof BotCreate
     */
    'content'?: object;
    /**
     * 
     * @type {string}
     * @memberof BotCreate
     */
    'activation_code': string;
    /**
     * 
     * @type {number}
     * @memberof BotCreate
     */
    'rate': number;
}
/**
 * 
 * @export
 * @interface BotOut
 */
export interface BotOut {
    /**
     * 
     * @type {number}
     * @memberof BotOut
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof BotOut
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof BotOut
     */
    'description': string;
    /**
     * 
     * @type {object}
     * @memberof BotOut
     */
    'content': object;
    /**
     * 
     * @type {string}
     * @memberof BotOut
     */
    'activation_code': string;
    /**
     * 
     * @type {number}
     * @memberof BotOut
     */
    'rate': number;
}
/**
 * 
 * @export
 * @interface BotUpdate
 */
export interface BotUpdate {
    /**
     * 
     * @type {string}
     * @memberof BotUpdate
     */
    'title'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BotUpdate
     */
    'description'?: string | null;
    /**
     * 
     * @type {object}
     * @memberof BotUpdate
     */
    'content'?: object | null;
    /**
     * 
     * @type {string}
     * @memberof BotUpdate
     */
    'activation_code'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof BotUpdate
     */
    'rate'?: number | null;
}
/**
 * 
 * @export
 * @interface ChangePasswordIn
 */
export interface ChangePasswordIn {
    /**
     * 
     * @type {string}
     * @memberof ChangePasswordIn
     */
    'current_password': string;
    /**
     * 
     * @type {string}
     * @memberof ChangePasswordIn
     */
    'new_password': string;
}
/**
 * 
 * @export
 * @interface ForgotPasswordIn
 */
export interface ForgotPasswordIn {
    /**
     * 
     * @type {string}
     * @memberof ForgotPasswordIn
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
    /**
     * 
     * @type {Array<ValidationError>}
     * @memberof HTTPValidationError
     */
    'detail'?: Array<ValidationError>;
}
/**
 * 
 * @export
 * @interface InstanceCreate
 */
export interface InstanceCreate {
    /**
     * 
     * @type {number}
     * @memberof InstanceCreate
     */
    'bot_id': number;
    /**
     * 
     * @type {string}
     * @memberof InstanceCreate
     */
    'title': string;
    /**
     * 
     * @type {object}
     * @memberof InstanceCreate
     */
    'config'?: object;
}
/**
 * 
 * @export
 * @interface InstanceOut
 */
export interface InstanceOut {
    /**
     * 
     * @type {number}
     * @memberof InstanceOut
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof InstanceOut
     */
    'user_id': number;
    /**
     * 
     * @type {number}
     * @memberof InstanceOut
     */
    'bot_id': number;
    /**
     * 
     * @type {string}
     * @memberof InstanceOut
     */
    'instance_id': string;
    /**
     * 
     * @type {string}
     * @memberof InstanceOut
     */
    'title': string;
    /**
     * 
     * @type {object}
     * @memberof InstanceOut
     */
    'config': object;
    /**
     * 
     * @type {InstanceStatus}
     * @memberof InstanceOut
     */
    'status': InstanceStatus;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const InstanceStatus = {
    Active: 'active',
    Paused: 'paused',
    NotEnoughBalance: 'not_enough_balance'
} as const;

export type InstanceStatus = typeof InstanceStatus[keyof typeof InstanceStatus];


/**
 * 
 * @export
 * @interface InstanceUpdate
 */
export interface InstanceUpdate {
    /**
     * 
     * @type {string}
     * @memberof InstanceUpdate
     */
    'title'?: string | null;
    /**
     * 
     * @type {object}
     * @memberof InstanceUpdate
     */
    'config'?: object | null;
    /**
     * 
     * @type {InstanceStatus}
     * @memberof InstanceUpdate
     */
    'status'?: InstanceStatus | null;
}


/**
 * 
 * @export
 * @interface LocationInner
 */
export interface LocationInner {
}
/**
 * 
 * @export
 * @interface LoginIn
 */
export interface LoginIn {
    /**
     * 
     * @type {string}
     * @memberof LoginIn
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof LoginIn
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface Message
 */
export interface Message {
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface RegisterIn
 */
export interface RegisterIn {
    /**
     * 
     * @type {string}
     * @memberof RegisterIn
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof RegisterIn
     */
    'surname': string;
    /**
     * 
     * @type {string}
     * @memberof RegisterIn
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof RegisterIn
     */
    'phone': string;
    /**
     * 
     * @type {string}
     * @memberof RegisterIn
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof RegisterIn
     */
    'telegram'?: string | null;
}
/**
 * 
 * @export
 * @interface ResetPasswordIn
 */
export interface ResetPasswordIn {
    /**
     * 
     * @type {string}
     * @memberof ResetPasswordIn
     */
    'token': string;
    /**
     * 
     * @type {string}
     * @memberof ResetPasswordIn
     */
    'new_password': string;
}
/**
 * 
 * @export
 * @interface TokenPair
 */
export interface TokenPair {
    /**
     * 
     * @type {string}
     * @memberof TokenPair
     */
    'session_token': string;
    /**
     * 
     * @type {string}
     * @memberof TokenPair
     */
    'refresh_token': string;
}
/**
 * 
 * @export
 * @interface UserOut
 */
export interface UserOut {
    /**
     * 
     * @type {number}
     * @memberof UserOut
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof UserOut
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof UserOut
     */
    'surname': string;
    /**
     * 
     * @type {string}
     * @memberof UserOut
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof UserOut
     */
    'phone': string;
    /**
     * 
     * @type {string}
     * @memberof UserOut
     */
    'telegram'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof UserOut
     */
    'balance': number;
}
/**
 * 
 * @export
 * @interface UserUpdate
 */
export interface UserUpdate {
    /**
     * 
     * @type {string}
     * @memberof UserUpdate
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserUpdate
     */
    'surname'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserUpdate
     */
    'phone'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserUpdate
     */
    'telegram'?: string | null;
}
/**
 * 
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * 
     * @type {Array<LocationInner>}
     * @memberof ValidationError
     */
    'loc': Array<LocationInner>;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface VerifyEmailIn
 */
export interface VerifyEmailIn {
    /**
     * 
     * @type {string}
     * @memberof VerifyEmailIn
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof VerifyEmailIn
     */
    'code': string;
}

/**
 * AdminApi - axios parameter creator
 * @export
 */
export const AdminApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get User
         * @param {number} uid 
         * @param {string | null} [xAdminKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAdminUsersUidGet: async (uid: number, xAdminKey?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('getUserAdminUsersUidGet', 'uid', uid)
            const localVarPath = `/admin/users/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (xAdminKey != null) {
                localVarHeaderParameter['X-Admin-Key'] = String(xAdminKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Users
         * @param {string | null} [xAdminKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsersAdminUsersGet: async (xAdminKey?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (xAdminKey != null) {
                localVarHeaderParameter['X-Admin-Key'] = String(xAdminKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch User
         * @param {number} uid 
         * @param {object} body 
         * @param {string | null} [xAdminKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchUserAdminUsersUidPatch: async (uid: number, body: object, xAdminKey?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('patchUserAdminUsersUidPatch', 'uid', uid)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('patchUserAdminUsersUidPatch', 'body', body)
            const localVarPath = `/admin/users/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xAdminKey != null) {
                localVarHeaderParameter['X-Admin-Key'] = String(xAdminKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminApi - functional programming interface
 * @export
 */
export const AdminApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdminApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get User
         * @param {number} uid 
         * @param {string | null} [xAdminKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserAdminUsersUidGet(uid: number, xAdminKey?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserAdminUsersUidGet(uid, xAdminKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.getUserAdminUsersUidGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List Users
         * @param {string | null} [xAdminKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUsersAdminUsersGet(xAdminKey?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserOut>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUsersAdminUsersGet(xAdminKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.listUsersAdminUsersGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Patch User
         * @param {number} uid 
         * @param {object} body 
         * @param {string | null} [xAdminKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchUserAdminUsersUidPatch(uid: number, body: object, xAdminKey?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchUserAdminUsersUidPatch(uid, body, xAdminKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.patchUserAdminUsersUidPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AdminApi - factory interface
 * @export
 */
export const AdminApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdminApiFp(configuration)
    return {
        /**
         * 
         * @summary Get User
         * @param {number} uid 
         * @param {string | null} [xAdminKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAdminUsersUidGet(uid: number, xAdminKey?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<UserOut> {
            return localVarFp.getUserAdminUsersUidGet(uid, xAdminKey, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Users
         * @param {string | null} [xAdminKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsersAdminUsersGet(xAdminKey?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<Array<UserOut>> {
            return localVarFp.listUsersAdminUsersGet(xAdminKey, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Patch User
         * @param {number} uid 
         * @param {object} body 
         * @param {string | null} [xAdminKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchUserAdminUsersUidPatch(uid: number, body: object, xAdminKey?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<UserOut> {
            return localVarFp.patchUserAdminUsersUidPatch(uid, body, xAdminKey, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminApi - object-oriented interface
 * @export
 * @class AdminApi
 * @extends {BaseAPI}
 */
export class AdminApi extends BaseAPI {
    /**
     * 
     * @summary Get User
     * @param {number} uid 
     * @param {string | null} [xAdminKey] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public getUserAdminUsersUidGet(uid: number, xAdminKey?: string | null, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).getUserAdminUsersUidGet(uid, xAdminKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Users
     * @param {string | null} [xAdminKey] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public listUsersAdminUsersGet(xAdminKey?: string | null, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).listUsersAdminUsersGet(xAdminKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Patch User
     * @param {number} uid 
     * @param {object} body 
     * @param {string | null} [xAdminKey] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public patchUserAdminUsersUidPatch(uid: number, body: object, xAdminKey?: string | null, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).patchUserAdminUsersUidPatch(uid, body, xAdminKey, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Change Password
         * @param {ChangePasswordIn} changePasswordIn 
         * @param {any} [xSessionToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePasswordAuthChangePasswordPost: async (changePasswordIn: ChangePasswordIn, xSessionToken?: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'changePasswordIn' is not null or undefined
            assertParamExists('changePasswordAuthChangePasswordPost', 'changePasswordIn', changePasswordIn)
            const localVarPath = `/auth/change-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xSessionToken != null) {
                localVarHeaderParameter['X-Session-Token'] = typeof xSessionToken === 'string'
                    ? xSessionToken
                    : JSON.stringify(xSessionToken);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(changePasswordIn, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Forgot Password
         * @param {ForgotPasswordIn} forgotPasswordIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forgotPasswordAuthForgotPasswordPost: async (forgotPasswordIn: ForgotPasswordIn, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'forgotPasswordIn' is not null or undefined
            assertParamExists('forgotPasswordAuthForgotPasswordPost', 'forgotPasswordIn', forgotPasswordIn)
            const localVarPath = `/auth/forgot-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(forgotPasswordIn, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Login
         * @param {LoginIn} loginIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginAuthLoginPost: async (loginIn: LoginIn, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginIn' is not null or undefined
            assertParamExists('loginAuthLoginPost', 'loginIn', loginIn)
            const localVarPath = `/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginIn, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Logout
         * @param {string | null} [xSessionToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutAuthLogoutPost: async (xSessionToken?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (xSessionToken != null) {
                localVarHeaderParameter['X-Session-Token'] = String(xSessionToken);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Refresh
         * @param {string | null} [xSessionToken] 
         * @param {string | null} [xRefreshToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshAuthRefreshPost: async (xSessionToken?: string | null, xRefreshToken?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (xSessionToken != null) {
                localVarHeaderParameter['X-Session-Token'] = String(xSessionToken);
            }
            if (xRefreshToken != null) {
                localVarHeaderParameter['X-Refresh-Token'] = String(xRefreshToken);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Register
         * @param {RegisterIn} registerIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerAuthRegisterPost: async (registerIn: RegisterIn, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'registerIn' is not null or undefined
            assertParamExists('registerAuthRegisterPost', 'registerIn', registerIn)
            const localVarPath = `/auth/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registerIn, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reset Password
         * @param {ResetPasswordIn} resetPasswordIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPasswordAuthResetPasswordPost: async (resetPasswordIn: ResetPasswordIn, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resetPasswordIn' is not null or undefined
            assertParamExists('resetPasswordAuthResetPasswordPost', 'resetPasswordIn', resetPasswordIn)
            const localVarPath = `/auth/reset-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resetPasswordIn, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Verify Email
         * @param {VerifyEmailIn} verifyEmailIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyEmailAuthVerifyEmailPost: async (verifyEmailIn: VerifyEmailIn, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'verifyEmailIn' is not null or undefined
            assertParamExists('verifyEmailAuthVerifyEmailPost', 'verifyEmailIn', verifyEmailIn)
            const localVarPath = `/auth/verify-email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(verifyEmailIn, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Change Password
         * @param {ChangePasswordIn} changePasswordIn 
         * @param {any} [xSessionToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changePasswordAuthChangePasswordPost(changePasswordIn: ChangePasswordIn, xSessionToken?: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenPair>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changePasswordAuthChangePasswordPost(changePasswordIn, xSessionToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.changePasswordAuthChangePasswordPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Forgot Password
         * @param {ForgotPasswordIn} forgotPasswordIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async forgotPasswordAuthForgotPasswordPost(forgotPasswordIn: ForgotPasswordIn, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.forgotPasswordAuthForgotPasswordPost(forgotPasswordIn, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.forgotPasswordAuthForgotPasswordPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Login
         * @param {LoginIn} loginIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loginAuthLoginPost(loginIn: LoginIn, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenPair>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loginAuthLoginPost(loginIn, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.loginAuthLoginPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Logout
         * @param {string | null} [xSessionToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logoutAuthLogoutPost(xSessionToken?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logoutAuthLogoutPost(xSessionToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.logoutAuthLogoutPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Refresh
         * @param {string | null} [xSessionToken] 
         * @param {string | null} [xRefreshToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshAuthRefreshPost(xSessionToken?: string | null, xRefreshToken?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenPair>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshAuthRefreshPost(xSessionToken, xRefreshToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.refreshAuthRefreshPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Register
         * @param {RegisterIn} registerIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerAuthRegisterPost(registerIn: RegisterIn, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerAuthRegisterPost(registerIn, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.registerAuthRegisterPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Reset Password
         * @param {ResetPasswordIn} resetPasswordIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetPasswordAuthResetPasswordPost(resetPasswordIn: ResetPasswordIn, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetPasswordAuthResetPasswordPost(resetPasswordIn, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.resetPasswordAuthResetPasswordPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Verify Email
         * @param {VerifyEmailIn} verifyEmailIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifyEmailAuthVerifyEmailPost(verifyEmailIn: VerifyEmailIn, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenPair>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verifyEmailAuthVerifyEmailPost(verifyEmailIn, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.verifyEmailAuthVerifyEmailPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * 
         * @summary Change Password
         * @param {ChangePasswordIn} changePasswordIn 
         * @param {any} [xSessionToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePasswordAuthChangePasswordPost(changePasswordIn: ChangePasswordIn, xSessionToken?: any, options?: RawAxiosRequestConfig): AxiosPromise<TokenPair> {
            return localVarFp.changePasswordAuthChangePasswordPost(changePasswordIn, xSessionToken, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Forgot Password
         * @param {ForgotPasswordIn} forgotPasswordIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forgotPasswordAuthForgotPasswordPost(forgotPasswordIn: ForgotPasswordIn, options?: RawAxiosRequestConfig): AxiosPromise<Message> {
            return localVarFp.forgotPasswordAuthForgotPasswordPost(forgotPasswordIn, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Login
         * @param {LoginIn} loginIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginAuthLoginPost(loginIn: LoginIn, options?: RawAxiosRequestConfig): AxiosPromise<TokenPair> {
            return localVarFp.loginAuthLoginPost(loginIn, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Logout
         * @param {string | null} [xSessionToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutAuthLogoutPost(xSessionToken?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<Message> {
            return localVarFp.logoutAuthLogoutPost(xSessionToken, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Refresh
         * @param {string | null} [xSessionToken] 
         * @param {string | null} [xRefreshToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshAuthRefreshPost(xSessionToken?: string | null, xRefreshToken?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<TokenPair> {
            return localVarFp.refreshAuthRefreshPost(xSessionToken, xRefreshToken, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Register
         * @param {RegisterIn} registerIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerAuthRegisterPost(registerIn: RegisterIn, options?: RawAxiosRequestConfig): AxiosPromise<Message> {
            return localVarFp.registerAuthRegisterPost(registerIn, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reset Password
         * @param {ResetPasswordIn} resetPasswordIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPasswordAuthResetPasswordPost(resetPasswordIn: ResetPasswordIn, options?: RawAxiosRequestConfig): AxiosPromise<Message> {
            return localVarFp.resetPasswordAuthResetPasswordPost(resetPasswordIn, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Verify Email
         * @param {VerifyEmailIn} verifyEmailIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyEmailAuthVerifyEmailPost(verifyEmailIn: VerifyEmailIn, options?: RawAxiosRequestConfig): AxiosPromise<TokenPair> {
            return localVarFp.verifyEmailAuthVerifyEmailPost(verifyEmailIn, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * 
     * @summary Change Password
     * @param {ChangePasswordIn} changePasswordIn 
     * @param {any} [xSessionToken] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public changePasswordAuthChangePasswordPost(changePasswordIn: ChangePasswordIn, xSessionToken?: any, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).changePasswordAuthChangePasswordPost(changePasswordIn, xSessionToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Forgot Password
     * @param {ForgotPasswordIn} forgotPasswordIn 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public forgotPasswordAuthForgotPasswordPost(forgotPasswordIn: ForgotPasswordIn, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).forgotPasswordAuthForgotPasswordPost(forgotPasswordIn, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Login
     * @param {LoginIn} loginIn 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public loginAuthLoginPost(loginIn: LoginIn, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).loginAuthLoginPost(loginIn, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Logout
     * @param {string | null} [xSessionToken] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public logoutAuthLogoutPost(xSessionToken?: string | null, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).logoutAuthLogoutPost(xSessionToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Refresh
     * @param {string | null} [xSessionToken] 
     * @param {string | null} [xRefreshToken] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public refreshAuthRefreshPost(xSessionToken?: string | null, xRefreshToken?: string | null, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).refreshAuthRefreshPost(xSessionToken, xRefreshToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Register
     * @param {RegisterIn} registerIn 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public registerAuthRegisterPost(registerIn: RegisterIn, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).registerAuthRegisterPost(registerIn, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reset Password
     * @param {ResetPasswordIn} resetPasswordIn 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public resetPasswordAuthResetPasswordPost(resetPasswordIn: ResetPasswordIn, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).resetPasswordAuthResetPasswordPost(resetPasswordIn, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Verify Email
     * @param {VerifyEmailIn} verifyEmailIn 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public verifyEmailAuthVerifyEmailPost(verifyEmailIn: VerifyEmailIn, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).verifyEmailAuthVerifyEmailPost(verifyEmailIn, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BotsApi - axios parameter creator
 * @export
 */
export const BotsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Bot
         * @param {BotCreate} botCreate 
         * @param {string | null} [xAdminKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBotBotsPost: async (botCreate: BotCreate, xAdminKey?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'botCreate' is not null or undefined
            assertParamExists('createBotBotsPost', 'botCreate', botCreate)
            const localVarPath = `/bots`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xAdminKey != null) {
                localVarHeaderParameter['X-Admin-Key'] = String(xAdminKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(botCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Bot
         * @param {number} botId 
         * @param {string | null} [xAdminKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBotBotsBotIdDelete: async (botId: number, xAdminKey?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'botId' is not null or undefined
            assertParamExists('deleteBotBotsBotIdDelete', 'botId', botId)
            const localVarPath = `/bots/{bot_id}`
                .replace(`{${"bot_id"}}`, encodeURIComponent(String(botId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (xAdminKey != null) {
                localVarHeaderParameter['X-Admin-Key'] = String(xAdminKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Bots
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBotsBotsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/bots`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Bot
         * @param {number} botId 
         * @param {BotUpdate} botUpdate 
         * @param {string | null} [xAdminKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBotBotsBotIdPut: async (botId: number, botUpdate: BotUpdate, xAdminKey?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'botId' is not null or undefined
            assertParamExists('updateBotBotsBotIdPut', 'botId', botId)
            // verify required parameter 'botUpdate' is not null or undefined
            assertParamExists('updateBotBotsBotIdPut', 'botUpdate', botUpdate)
            const localVarPath = `/bots/{bot_id}`
                .replace(`{${"bot_id"}}`, encodeURIComponent(String(botId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xAdminKey != null) {
                localVarHeaderParameter['X-Admin-Key'] = String(xAdminKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(botUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BotsApi - functional programming interface
 * @export
 */
export const BotsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BotsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create Bot
         * @param {BotCreate} botCreate 
         * @param {string | null} [xAdminKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBotBotsPost(botCreate: BotCreate, xAdminKey?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BotOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBotBotsPost(botCreate, xAdminKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BotsApi.createBotBotsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Bot
         * @param {number} botId 
         * @param {string | null} [xAdminKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBotBotsBotIdDelete(botId: number, xAdminKey?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteBotBotsBotIdDelete(botId, xAdminKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BotsApi.deleteBotBotsBotIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List Bots
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listBotsBotsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BotOut>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listBotsBotsGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BotsApi.listBotsBotsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Bot
         * @param {number} botId 
         * @param {BotUpdate} botUpdate 
         * @param {string | null} [xAdminKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateBotBotsBotIdPut(botId: number, botUpdate: BotUpdate, xAdminKey?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BotOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateBotBotsBotIdPut(botId, botUpdate, xAdminKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BotsApi.updateBotBotsBotIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BotsApi - factory interface
 * @export
 */
export const BotsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BotsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create Bot
         * @param {BotCreate} botCreate 
         * @param {string | null} [xAdminKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBotBotsPost(botCreate: BotCreate, xAdminKey?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<BotOut> {
            return localVarFp.createBotBotsPost(botCreate, xAdminKey, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Bot
         * @param {number} botId 
         * @param {string | null} [xAdminKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBotBotsBotIdDelete(botId: number, xAdminKey?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.deleteBotBotsBotIdDelete(botId, xAdminKey, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Bots
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBotsBotsGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<BotOut>> {
            return localVarFp.listBotsBotsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Bot
         * @param {number} botId 
         * @param {BotUpdate} botUpdate 
         * @param {string | null} [xAdminKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBotBotsBotIdPut(botId: number, botUpdate: BotUpdate, xAdminKey?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<BotOut> {
            return localVarFp.updateBotBotsBotIdPut(botId, botUpdate, xAdminKey, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BotsApi - object-oriented interface
 * @export
 * @class BotsApi
 * @extends {BaseAPI}
 */
export class BotsApi extends BaseAPI {
    /**
     * 
     * @summary Create Bot
     * @param {BotCreate} botCreate 
     * @param {string | null} [xAdminKey] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotsApi
     */
    public createBotBotsPost(botCreate: BotCreate, xAdminKey?: string | null, options?: RawAxiosRequestConfig) {
        return BotsApiFp(this.configuration).createBotBotsPost(botCreate, xAdminKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Bot
     * @param {number} botId 
     * @param {string | null} [xAdminKey] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotsApi
     */
    public deleteBotBotsBotIdDelete(botId: number, xAdminKey?: string | null, options?: RawAxiosRequestConfig) {
        return BotsApiFp(this.configuration).deleteBotBotsBotIdDelete(botId, xAdminKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Bots
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotsApi
     */
    public listBotsBotsGet(options?: RawAxiosRequestConfig) {
        return BotsApiFp(this.configuration).listBotsBotsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Bot
     * @param {number} botId 
     * @param {BotUpdate} botUpdate 
     * @param {string | null} [xAdminKey] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotsApi
     */
    public updateBotBotsBotIdPut(botId: number, botUpdate: BotUpdate, xAdminKey?: string | null, options?: RawAxiosRequestConfig) {
        return BotsApiFp(this.configuration).updateBotBotsBotIdPut(botId, botUpdate, xAdminKey, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * InstancesApi - axios parameter creator
 * @export
 */
export const InstancesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Instance
         * @param {InstanceCreate} instanceCreate 
         * @param {string | null} [xSessionToken] 
         * @param {string | null} [xRefreshToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInstanceInstancesPost: async (instanceCreate: InstanceCreate, xSessionToken?: string | null, xRefreshToken?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'instanceCreate' is not null or undefined
            assertParamExists('createInstanceInstancesPost', 'instanceCreate', instanceCreate)
            const localVarPath = `/instances`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xSessionToken != null) {
                localVarHeaderParameter['X-Session-Token'] = String(xSessionToken);
            }
            if (xRefreshToken != null) {
                localVarHeaderParameter['X-Refresh-Token'] = String(xRefreshToken);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(instanceCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Instance
         * @param {number} iid 
         * @param {string | null} [xSessionToken] 
         * @param {string | null} [xRefreshToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInstanceInstancesIidDelete: async (iid: number, xSessionToken?: string | null, xRefreshToken?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'iid' is not null or undefined
            assertParamExists('deleteInstanceInstancesIidDelete', 'iid', iid)
            const localVarPath = `/instances/{iid}`
                .replace(`{${"iid"}}`, encodeURIComponent(String(iid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (xSessionToken != null) {
                localVarHeaderParameter['X-Session-Token'] = String(xSessionToken);
            }
            if (xRefreshToken != null) {
                localVarHeaderParameter['X-Refresh-Token'] = String(xRefreshToken);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Instance
         * @param {number} iid 
         * @param {string | null} [xSessionToken] 
         * @param {string | null} [xRefreshToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstanceInstancesIidGet: async (iid: number, xSessionToken?: string | null, xRefreshToken?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'iid' is not null or undefined
            assertParamExists('getInstanceInstancesIidGet', 'iid', iid)
            const localVarPath = `/instances/{iid}`
                .replace(`{${"iid"}}`, encodeURIComponent(String(iid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (xSessionToken != null) {
                localVarHeaderParameter['X-Session-Token'] = String(xSessionToken);
            }
            if (xRefreshToken != null) {
                localVarHeaderParameter['X-Refresh-Token'] = String(xRefreshToken);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Instances
         * @param {string | null} [xSessionToken] 
         * @param {string | null} [xRefreshToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInstancesInstancesGet: async (xSessionToken?: string | null, xRefreshToken?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/instances`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (xSessionToken != null) {
                localVarHeaderParameter['X-Session-Token'] = String(xSessionToken);
            }
            if (xRefreshToken != null) {
                localVarHeaderParameter['X-Refresh-Token'] = String(xRefreshToken);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Pause Instance
         * @param {number} iid 
         * @param {string | null} [xSessionToken] 
         * @param {string | null} [xRefreshToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pauseInstanceInstancesIidPausePatch: async (iid: number, xSessionToken?: string | null, xRefreshToken?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'iid' is not null or undefined
            assertParamExists('pauseInstanceInstancesIidPausePatch', 'iid', iid)
            const localVarPath = `/instances/{iid}/pause`
                .replace(`{${"iid"}}`, encodeURIComponent(String(iid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (xSessionToken != null) {
                localVarHeaderParameter['X-Session-Token'] = String(xSessionToken);
            }
            if (xRefreshToken != null) {
                localVarHeaderParameter['X-Refresh-Token'] = String(xRefreshToken);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Resume Instance
         * @param {number} iid 
         * @param {string | null} [xSessionToken] 
         * @param {string | null} [xRefreshToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resumeInstanceInstancesIidResumePatch: async (iid: number, xSessionToken?: string | null, xRefreshToken?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'iid' is not null or undefined
            assertParamExists('resumeInstanceInstancesIidResumePatch', 'iid', iid)
            const localVarPath = `/instances/{iid}/resume`
                .replace(`{${"iid"}}`, encodeURIComponent(String(iid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (xSessionToken != null) {
                localVarHeaderParameter['X-Session-Token'] = String(xSessionToken);
            }
            if (xRefreshToken != null) {
                localVarHeaderParameter['X-Refresh-Token'] = String(xRefreshToken);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Instance
         * @param {number} iid 
         * @param {InstanceUpdate} instanceUpdate 
         * @param {string | null} [xSessionToken] 
         * @param {string | null} [xRefreshToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInstanceInstancesIidPut: async (iid: number, instanceUpdate: InstanceUpdate, xSessionToken?: string | null, xRefreshToken?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'iid' is not null or undefined
            assertParamExists('updateInstanceInstancesIidPut', 'iid', iid)
            // verify required parameter 'instanceUpdate' is not null or undefined
            assertParamExists('updateInstanceInstancesIidPut', 'instanceUpdate', instanceUpdate)
            const localVarPath = `/instances/{iid}`
                .replace(`{${"iid"}}`, encodeURIComponent(String(iid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xSessionToken != null) {
                localVarHeaderParameter['X-Session-Token'] = String(xSessionToken);
            }
            if (xRefreshToken != null) {
                localVarHeaderParameter['X-Refresh-Token'] = String(xRefreshToken);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(instanceUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InstancesApi - functional programming interface
 * @export
 */
export const InstancesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InstancesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create Instance
         * @param {InstanceCreate} instanceCreate 
         * @param {string | null} [xSessionToken] 
         * @param {string | null} [xRefreshToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createInstanceInstancesPost(instanceCreate: InstanceCreate, xSessionToken?: string | null, xRefreshToken?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InstanceOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createInstanceInstancesPost(instanceCreate, xSessionToken, xRefreshToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InstancesApi.createInstanceInstancesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete Instance
         * @param {number} iid 
         * @param {string | null} [xSessionToken] 
         * @param {string | null} [xRefreshToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteInstanceInstancesIidDelete(iid: number, xSessionToken?: string | null, xRefreshToken?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteInstanceInstancesIidDelete(iid, xSessionToken, xRefreshToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InstancesApi.deleteInstanceInstancesIidDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Instance
         * @param {number} iid 
         * @param {string | null} [xSessionToken] 
         * @param {string | null} [xRefreshToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInstanceInstancesIidGet(iid: number, xSessionToken?: string | null, xRefreshToken?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InstanceOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInstanceInstancesIidGet(iid, xSessionToken, xRefreshToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InstancesApi.getInstanceInstancesIidGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List Instances
         * @param {string | null} [xSessionToken] 
         * @param {string | null} [xRefreshToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listInstancesInstancesGet(xSessionToken?: string | null, xRefreshToken?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InstanceOut>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listInstancesInstancesGet(xSessionToken, xRefreshToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InstancesApi.listInstancesInstancesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Pause Instance
         * @param {number} iid 
         * @param {string | null} [xSessionToken] 
         * @param {string | null} [xRefreshToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pauseInstanceInstancesIidPausePatch(iid: number, xSessionToken?: string | null, xRefreshToken?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InstanceOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pauseInstanceInstancesIidPausePatch(iid, xSessionToken, xRefreshToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InstancesApi.pauseInstanceInstancesIidPausePatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Resume Instance
         * @param {number} iid 
         * @param {string | null} [xSessionToken] 
         * @param {string | null} [xRefreshToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resumeInstanceInstancesIidResumePatch(iid: number, xSessionToken?: string | null, xRefreshToken?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InstanceOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resumeInstanceInstancesIidResumePatch(iid, xSessionToken, xRefreshToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InstancesApi.resumeInstanceInstancesIidResumePatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Instance
         * @param {number} iid 
         * @param {InstanceUpdate} instanceUpdate 
         * @param {string | null} [xSessionToken] 
         * @param {string | null} [xRefreshToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateInstanceInstancesIidPut(iid: number, instanceUpdate: InstanceUpdate, xSessionToken?: string | null, xRefreshToken?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InstanceOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateInstanceInstancesIidPut(iid, instanceUpdate, xSessionToken, xRefreshToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InstancesApi.updateInstanceInstancesIidPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * InstancesApi - factory interface
 * @export
 */
export const InstancesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InstancesApiFp(configuration)
    return {
        /**
         * 
         * @summary Create Instance
         * @param {InstanceCreate} instanceCreate 
         * @param {string | null} [xSessionToken] 
         * @param {string | null} [xRefreshToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInstanceInstancesPost(instanceCreate: InstanceCreate, xSessionToken?: string | null, xRefreshToken?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<InstanceOut> {
            return localVarFp.createInstanceInstancesPost(instanceCreate, xSessionToken, xRefreshToken, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Instance
         * @param {number} iid 
         * @param {string | null} [xSessionToken] 
         * @param {string | null} [xRefreshToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInstanceInstancesIidDelete(iid: number, xSessionToken?: string | null, xRefreshToken?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.deleteInstanceInstancesIidDelete(iid, xSessionToken, xRefreshToken, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Instance
         * @param {number} iid 
         * @param {string | null} [xSessionToken] 
         * @param {string | null} [xRefreshToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstanceInstancesIidGet(iid: number, xSessionToken?: string | null, xRefreshToken?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<InstanceOut> {
            return localVarFp.getInstanceInstancesIidGet(iid, xSessionToken, xRefreshToken, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Instances
         * @param {string | null} [xSessionToken] 
         * @param {string | null} [xRefreshToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInstancesInstancesGet(xSessionToken?: string | null, xRefreshToken?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<Array<InstanceOut>> {
            return localVarFp.listInstancesInstancesGet(xSessionToken, xRefreshToken, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Pause Instance
         * @param {number} iid 
         * @param {string | null} [xSessionToken] 
         * @param {string | null} [xRefreshToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pauseInstanceInstancesIidPausePatch(iid: number, xSessionToken?: string | null, xRefreshToken?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<InstanceOut> {
            return localVarFp.pauseInstanceInstancesIidPausePatch(iid, xSessionToken, xRefreshToken, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Resume Instance
         * @param {number} iid 
         * @param {string | null} [xSessionToken] 
         * @param {string | null} [xRefreshToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resumeInstanceInstancesIidResumePatch(iid: number, xSessionToken?: string | null, xRefreshToken?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<InstanceOut> {
            return localVarFp.resumeInstanceInstancesIidResumePatch(iid, xSessionToken, xRefreshToken, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Instance
         * @param {number} iid 
         * @param {InstanceUpdate} instanceUpdate 
         * @param {string | null} [xSessionToken] 
         * @param {string | null} [xRefreshToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInstanceInstancesIidPut(iid: number, instanceUpdate: InstanceUpdate, xSessionToken?: string | null, xRefreshToken?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<InstanceOut> {
            return localVarFp.updateInstanceInstancesIidPut(iid, instanceUpdate, xSessionToken, xRefreshToken, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InstancesApi - object-oriented interface
 * @export
 * @class InstancesApi
 * @extends {BaseAPI}
 */
export class InstancesApi extends BaseAPI {
    /**
     * 
     * @summary Create Instance
     * @param {InstanceCreate} instanceCreate 
     * @param {string | null} [xSessionToken] 
     * @param {string | null} [xRefreshToken] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstancesApi
     */
    public createInstanceInstancesPost(instanceCreate: InstanceCreate, xSessionToken?: string | null, xRefreshToken?: string | null, options?: RawAxiosRequestConfig) {
        return InstancesApiFp(this.configuration).createInstanceInstancesPost(instanceCreate, xSessionToken, xRefreshToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Instance
     * @param {number} iid 
     * @param {string | null} [xSessionToken] 
     * @param {string | null} [xRefreshToken] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstancesApi
     */
    public deleteInstanceInstancesIidDelete(iid: number, xSessionToken?: string | null, xRefreshToken?: string | null, options?: RawAxiosRequestConfig) {
        return InstancesApiFp(this.configuration).deleteInstanceInstancesIidDelete(iid, xSessionToken, xRefreshToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Instance
     * @param {number} iid 
     * @param {string | null} [xSessionToken] 
     * @param {string | null} [xRefreshToken] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstancesApi
     */
    public getInstanceInstancesIidGet(iid: number, xSessionToken?: string | null, xRefreshToken?: string | null, options?: RawAxiosRequestConfig) {
        return InstancesApiFp(this.configuration).getInstanceInstancesIidGet(iid, xSessionToken, xRefreshToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Instances
     * @param {string | null} [xSessionToken] 
     * @param {string | null} [xRefreshToken] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstancesApi
     */
    public listInstancesInstancesGet(xSessionToken?: string | null, xRefreshToken?: string | null, options?: RawAxiosRequestConfig) {
        return InstancesApiFp(this.configuration).listInstancesInstancesGet(xSessionToken, xRefreshToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Pause Instance
     * @param {number} iid 
     * @param {string | null} [xSessionToken] 
     * @param {string | null} [xRefreshToken] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstancesApi
     */
    public pauseInstanceInstancesIidPausePatch(iid: number, xSessionToken?: string | null, xRefreshToken?: string | null, options?: RawAxiosRequestConfig) {
        return InstancesApiFp(this.configuration).pauseInstanceInstancesIidPausePatch(iid, xSessionToken, xRefreshToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Resume Instance
     * @param {number} iid 
     * @param {string | null} [xSessionToken] 
     * @param {string | null} [xRefreshToken] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstancesApi
     */
    public resumeInstanceInstancesIidResumePatch(iid: number, xSessionToken?: string | null, xRefreshToken?: string | null, options?: RawAxiosRequestConfig) {
        return InstancesApiFp(this.configuration).resumeInstanceInstancesIidResumePatch(iid, xSessionToken, xRefreshToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Instance
     * @param {number} iid 
     * @param {InstanceUpdate} instanceUpdate 
     * @param {string | null} [xSessionToken] 
     * @param {string | null} [xRefreshToken] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstancesApi
     */
    public updateInstanceInstancesIidPut(iid: number, instanceUpdate: InstanceUpdate, xSessionToken?: string | null, xRefreshToken?: string | null, options?: RawAxiosRequestConfig) {
        return InstancesApiFp(this.configuration).updateInstanceInstancesIidPut(iid, instanceUpdate, xSessionToken, xRefreshToken, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Me
         * @param {string | null} [xSessionToken] 
         * @param {string | null} [xRefreshToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMeUsersMeGet: async (xSessionToken?: string | null, xRefreshToken?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (xSessionToken != null) {
                localVarHeaderParameter['X-Session-Token'] = String(xSessionToken);
            }
            if (xRefreshToken != null) {
                localVarHeaderParameter['X-Refresh-Token'] = String(xRefreshToken);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Me
         * @param {UserUpdate} userUpdate 
         * @param {string | null} [xSessionToken] 
         * @param {string | null} [xRefreshToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMeUsersMePatch: async (userUpdate: UserUpdate, xSessionToken?: string | null, xRefreshToken?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userUpdate' is not null or undefined
            assertParamExists('updateMeUsersMePatch', 'userUpdate', userUpdate)
            const localVarPath = `/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xSessionToken != null) {
                localVarHeaderParameter['X-Session-Token'] = String(xSessionToken);
            }
            if (xRefreshToken != null) {
                localVarHeaderParameter['X-Refresh-Token'] = String(xRefreshToken);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get Me
         * @param {string | null} [xSessionToken] 
         * @param {string | null} [xRefreshToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMeUsersMeGet(xSessionToken?: string | null, xRefreshToken?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMeUsersMeGet(xSessionToken, xRefreshToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getMeUsersMeGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update Me
         * @param {UserUpdate} userUpdate 
         * @param {string | null} [xSessionToken] 
         * @param {string | null} [xRefreshToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMeUsersMePatch(userUpdate: UserUpdate, xSessionToken?: string | null, xRefreshToken?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMeUsersMePatch(userUpdate, xSessionToken, xRefreshToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.updateMeUsersMePatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * 
         * @summary Get Me
         * @param {string | null} [xSessionToken] 
         * @param {string | null} [xRefreshToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMeUsersMeGet(xSessionToken?: string | null, xRefreshToken?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<UserOut> {
            return localVarFp.getMeUsersMeGet(xSessionToken, xRefreshToken, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Me
         * @param {UserUpdate} userUpdate 
         * @param {string | null} [xSessionToken] 
         * @param {string | null} [xRefreshToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMeUsersMePatch(userUpdate: UserUpdate, xSessionToken?: string | null, xRefreshToken?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<UserOut> {
            return localVarFp.updateMeUsersMePatch(userUpdate, xSessionToken, xRefreshToken, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * 
     * @summary Get Me
     * @param {string | null} [xSessionToken] 
     * @param {string | null} [xRefreshToken] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getMeUsersMeGet(xSessionToken?: string | null, xRefreshToken?: string | null, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getMeUsersMeGet(xSessionToken, xRefreshToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Me
     * @param {UserUpdate} userUpdate 
     * @param {string | null} [xSessionToken] 
     * @param {string | null} [xRefreshToken] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateMeUsersMePatch(userUpdate: UserUpdate, xSessionToken?: string | null, xRefreshToken?: string | null, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).updateMeUsersMePatch(userUpdate, xSessionToken, xRefreshToken, options).then((request) => request(this.axios, this.basePath));
    }
}



